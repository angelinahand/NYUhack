[{"/Users/angelinadeo/thehacktrical/NYUhack/src/index.js":"1","/Users/angelinadeo/thehacktrical/NYUhack/src/App.js":"2","/Users/angelinadeo/thehacktrical/NYUhack/src/reportWebVitals.js":"3","/Users/angelinadeo/thehacktrical/NYUhack/src/Timer.js":"4","/Users/angelinadeo/thehacktrical/NYUhack/src/landingScreen.js":"5","/Users/angelinadeo/thehacktrical/NYUhack/src/Settings.js":"6","/Users/angelinadeo/thehacktrical/NYUhack/src/SettingsContext.js":"7","/Users/angelinadeo/thehacktrical/NYUhack/src/SettingsButton.js":"8","/Users/angelinadeo/thehacktrical/NYUhack/src/PauseButton.js":"9","/Users/angelinadeo/thehacktrical/NYUhack/src/BackButton.js":"10","/Users/angelinadeo/thehacktrical/NYUhack/src/PlayButton.js":"11","/Users/angelinadeo/thehacktrical/NYUhack/src/timerpage.js":"12","/Users/angelinadeo/thehacktrical/NYUhack/src/colors.js":"13","/Users/angelinadeo/thehacktrical/NYUhack/src/util/demo.js":"14","/Users/angelinadeo/thehacktrical/NYUhack/src/util/mask.js":"15","/Users/angelinadeo/thehacktrical/NYUhack/src/util/analyzePoints.js":"16","/Users/angelinadeo/thehacktrical/NYUhack/src/Components/NavBar.js":"17"},{"size":500,"mtime":1645918429348,"results":"18","hashOfConfig":"19"},{"size":799,"mtime":1645922570332,"results":"20","hashOfConfig":"19"},{"size":362,"mtime":1645918429348,"results":"21","hashOfConfig":"19"},{"size":2839,"mtime":1645922489400,"results":"22","hashOfConfig":"19"},{"size":0,"mtime":1645918429348,"results":"23","hashOfConfig":"19"},{"size":1156,"mtime":1645918429347,"results":"24","hashOfConfig":"19"},{"size":109,"mtime":1645918429347,"results":"25","hashOfConfig":"19"},{"size":872,"mtime":1645918429347,"results":"26","hashOfConfig":"19"},{"size":424,"mtime":1645918429346,"results":"27","hashOfConfig":"19"},{"size":503,"mtime":1645918429346,"results":"28","hashOfConfig":"19"},{"size":158,"mtime":1645918429346,"results":"29","hashOfConfig":"19"},{"size":11789,"mtime":1645923660382,"results":"30","hashOfConfig":"19"},{"size":92,"mtime":1645922739143,"results":"31","hashOfConfig":"19"},{"size":4374,"mtime":1645922342985,"results":"32","hashOfConfig":"19"},{"size":4616,"mtime":1645921955988,"results":"33","hashOfConfig":"19"},{"size":6207,"mtime":1645923256661,"results":"34","hashOfConfig":"19"},{"size":1294,"mtime":1645923437280,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},"rfx77n",{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"39"},{"filePath":"44","messages":"45","suppressedMessages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"53","messages":"54","suppressedMessages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74"},{"filePath":"75","messages":"76","suppressedMessages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"39"},{"filePath":"79","messages":"80","suppressedMessages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"39"},{"filePath":"83","messages":"84","suppressedMessages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"39"},{"filePath":"87","messages":"88","suppressedMessages":"89","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"91"},{"filePath":"92","messages":"93","suppressedMessages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/angelinadeo/thehacktrical/NYUhack/src/index.js",[],[],["95","96"],"/Users/angelinadeo/thehacktrical/NYUhack/src/App.js",["97","98"],[],"import './App.css';\nimport Timer from \"./Timer\";\nimport Settings from \"./Settings\";\nimport landingScreen from \"./landingScreen\";\nimport {useState} from \"react\";\nimport SettingsContext from \"./SettingsContext\";\nimport TimerPage from './timerpage';\n\nfunction App() {\n\n  const [showSettings, setShowSettings] = useState(false);\n  const [workMinutes, setWorkMinutes] = useState(45);\n  const [breakMinutes, setBreakMinutes] = useState(15);\n\n  return (\n    <main>\n      <landingScreen />\n      <SettingsContext.Provider value={{\n        showSettings,\n        setShowSettings,\n        workMinutes,\n        breakMinutes,\n        setWorkMinutes,\n        setBreakMinutes,\n      }}>\n        {showSettings ? <Settings /> : <TimerPage />}\n      </SettingsContext.Provider>\n    </main>\n  );\n}\n\nexport default App;","/Users/angelinadeo/thehacktrical/NYUhack/src/reportWebVitals.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/Timer.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/landingScreen.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/Settings.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/SettingsContext.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/SettingsButton.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/PauseButton.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/BackButton.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/PlayButton.js",[],[],"/Users/angelinadeo/thehacktrical/NYUhack/src/timerpage.js",["99","100","101","102","103"],[],"import React, { useEffect, useState } from \"react\";\n// import colors from \"./colors\";\n// import NavBar from \"./Components/NavBar\";\nimport { Card, Flex, View, Heading, Button } from \"@aws-amplify/ui-react\";\nimport { CountdownCircleTimer } from \"react-countdown-circle-timer\";\nimport Demo from \"./util/demo\";\nimport { BarChart, Bar, CartesianGrid, XAxis, YAxis, Tooltip } from \"recharts\";\n// import useSound from \"use-sound\";\n// import alarm from \"../alarm.mp3\";\n\n/*const timeRotation = [\n  { state: \"focus\", time: 1500 },\n  { state: \"break\", time: 300 },\n  { state: \"focus\", time: 1500 },\n  { state: \"break\", time: 300 },\n  { state: \"focus\", time: 1500 },\n  { state: \"break\", time: 300 },\n  { state: \"focus\", time: 1500 },\n  { state: \"break\", time: 900 },\n];*/\nconst timeRotation = [\n  { state: \"focus\", time: 15 },\n  { state: \"break\", time: 3 },\n  { state: \"focus\", time: 15 },\n  { state: \"break\", time: 3 },\n  { state: \"focus\", time: 15 },\n  { state: \"break\", time: 3 },\n  { state: \"focus\", time: 15 },\n  { state: \"break\", time: 9 },\n];\n\nconst calcFocusedPercent = (focusSwitchTimes) => {\n  let totalTime = 0;\n  let focusedTime = 0;\n\n  focusSwitchTimes.forEach((focusSwitch, idx) => {\n    if (idx !== 0) {\n      let switchTime = focusSwitch.time;\n\n      let prevSwitch = focusSwitchTimes[idx - 1];\n      let prevSwitchTime = prevSwitch.time;\n      let prevSwitchState = prevSwitch.focus;\n      let dt = switchTime - prevSwitchTime;\n\n      if (prevSwitchState === \"focused\") {\n        focusedTime += dt;\n        totalTime += dt;\n      } else if (prevSwitchState === \"unfocused\") {\n        totalTime += dt;\n      }\n    }\n  });\n\n  return { focusedTime, totalTime };\n};\n\nconst TimerPage = () => {\n  const [playing, setPlaying] = useState(false);\n  const [timerIdx, setTimerIdx] = useState(0);\n  const [time, setTime] = useState(timeRotation[timerIdx].time);\n  const [remaining, setRemaining] = useState(timeRotation[timerIdx].time);\n  const [reset, setReset] = useState(0);\n  const [focused, setFocused] = useState(true);\n  const [focusSwitchTimes, setFocusSwitchTimes] = useState([]);\n  const [started, setStarted] = useState(false);\n  const [focusedTime, setFocusedTime] = useState([]);\n\n//   const [play, { stop }] = useSound(alarm);\n\n  function str_pad_left(string, pad, length) {\n    return (new Array(length + 1).join(pad) + string).slice(-length);\n  }\n\n  useEffect(() => {\n    if (started) {\n      if (!playing) {\n        setFocusSwitchTimes((prev) => {\n          return [...prev, { time: new Date().getTime(), focus: \"pause\" }];\n        });\n      } else {\n        setFocusSwitchTimes((prev) => {\n          return [\n            ...prev,\n            {\n              time: new Date().getTime(),\n              focus: focused ? \"focused\" : \"unfocused\",\n            },\n          ];\n        });\n      }\n    }\n  }, [playing]);\n\n  useEffect(() => {\n    if (started) {\n      if (timeRotation[timerIdx].state === \"break\") {\n        setFocusSwitchTimes((prev) => {\n          return [...prev, { time: new Date().getTime(), focus: \"break\" }];\n        });\n      } else {\n        setFocusSwitchTimes((prev) => {\n          return [\n            ...prev,\n            {\n              time: new Date().getTime(),\n              focus: focused ? \"focused\" : \"unfocused\",\n            },\n          ];\n        });\n      }\n    }\n  }, [timerIdx]);\n\n  useEffect(() => {\n    document.title = `${\n      timeRotation[timerIdx].state.charAt(0).toUpperCase() +\n      timeRotation[timerIdx].state.slice(1)\n    } ${Math.floor(remaining / 60)}:${str_pad_left(remaining % 60, \"0\", 2)}`;\n  }, [remaining]);\n\n  const displayFocusTime = () => {\n    let ft = calcFocusedPercent([\n      ...focusSwitchTimes,\n      { time: new Date().getTime(), focus: \"end\" },\n    ]);\n    let percentFocused = Math.floor((ft.focusedTime / ft.totalTime) * 100);\n    let precentUnfocused = 100 - percentFocused;\n    setFocusedTime([\n      {\n        name: `Session ${percentFocused}%`,\n        focused: percentFocused,\n        unfocused: precentUnfocused,\n      },\n    ]);\n  };\n\n  return (\n    <View\n      style={{\n        ...styles.parent,\n        backgroundColor: focused ? \"#7389AE\" : \"#FF6961\",\n      }}\n    >\n      <Demo\n        focusChange={(focused) => {\n          setFocused(focused);\n          if (playing && timeRotation[timerIdx].state === \"focus\") {\n            setFocusSwitchTimes((prev) => {\n              return [\n                ...prev,\n                {\n                  time: new Date().getTime(),\n                  focus: focused ? \"focused\" : \"unfocused\",\n                },\n              ];\n            });\n          }\n        }}\n      />\n      <div\n        style={{\n          display: \"flex\",\n          flexDirection: \"row\",\n          width: \"86%\",\n          justifyContent: \"space-around\",\n        }}\n      >\n        <div\n          style={{\n            paddingTop: \"40px\",\n            display: \"flex\",\n            flexDirection: \"column\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n          }}\n        >\n          <Heading\n            level={1}\n            style={{\n              fontFamily: \"inter\",\n              color: \"white\",\n              fontSize: \"70px\",\n              marginBottom: \"32px\",\n              textTransform: \"capitalize\",\n            }}\n          >\n            {timeRotation[timerIdx].state}\n          </Heading>\n          {focusedTime.length > 0 && !started ? (\n            <div\n              style={{\n                padding: \"16px\",\n                backgroundColor: \"#fff\",\n                borderRadius: \"16px\",\n              }}\n            >\n              <BarChart width={730} height={250} data={focusedTime}>\n                <CartesianGrid strokeDasharray=\"3 3\" />\n                <XAxis dataKey=\"name\" />\n                <YAxis min={0} max={100} />\n                <Tooltip />\n                <Bar dataKey=\"focused\" fill=\"#7389AE\" />\n                <Bar dataKey=\"unfocused\" fill=\"#FF6961\" />\n              </BarChart>\n            </div>\n          ) : (\n            <CountdownCircleTimer\n              key={reset}\n              isPlaying={playing}\n              duration={time}\n              trailColor=\"transparent\"\n              size={400}\n              strokeWidth={20}\n              colors={[[\"#fff\", 1]]}\n              onComplete={() => {\n                // play();\n                setTimerIdx((prev) => {\n                  const newIdx = (prev + 1) % timeRotation.length;\n                  setTime(timeRotation[newIdx].time);\n                  setRemaining(timeRotation[newIdx].time);\n                  setReset((prev) => prev + 1);\n                  return newIdx;\n                });\n              }}\n            >\n              {({ remainingTime }) => {\n                setRemaining(remainingTime);\n                return (\n                  <p\n                    style={{\n                      fontSize: 40,\n                      fontWeight: \"bold\",\n                      padding: 30,\n                      textAlign: \"center\",\n                    }}\n                  >\n                    {Math.floor(remainingTime / 60)}:\n                    {str_pad_left(remainingTime % 60, \"0\", 2)}\n                    <br></br>\n                    <p\n                      style={{\n                        fontSize: 30,\n                        fontWeight: \"normal\",\n                        textAlign: \"center\",\n                      }}\n                    >\n                      Next up{\" \"}\n                      {timeRotation[(timerIdx + 1) % timeRotation.length].state}{\" \"}\n                      for{\" \"}\n                      {Math.floor(\n                        timeRotation[(timerIdx + 1) % timeRotation.length]\n                          .time / 60\n                      )}{\" \"}\n                      minutes.\n                    </p>\n                  </p>\n                );\n              }}\n            </CountdownCircleTimer>\n          )}\n          <div\n            style={{\n              marginTop: \"32px\",\n              display: \"flex\",\n              flexDirection: \"column\",\n              justifyContent: \"center\",\n              alignItems: \"center\",\n            }}\n          >\n            <Button\n              style={styles.button}\n              onClick={() => {\n                if (!started) {\n                  setFocusSwitchTimes([]);\n                }\n                setStarted(true);\n                setPlaying((prev) => !prev);\n              }}\n            >\n              {playing ? \"Pause\" : \"Start\"}\n            </Button>\n            {started && (\n              <Button\n                style={styles.button}\n                onClick={() => {\n                  setTimerIdx(0);\n                  setStarted(false);\n                  setPlaying(false);\n                  setReset((prev) => prev + 1);\n                  setRemaining(0);\n                  setFocusSwitchTimes((prev) => {\n                    return [\n                      ...prev,\n                      { time: new Date().getTime(), focus: \"reset\" },\n                    ];\n                  });\n                  displayFocusTime();\n                }}\n              >\n                End\n              </Button>\n            )}\n            {!playing && remaining < time && started && (\n              <Button\n                style={styles.button}\n                onClick={() => {\n                  setTime(time);\n                  setRemaining(time);\n                  setReset((prev) => prev + 1);\n                }}\n              >\n                Reset\n              </Button>\n            )}\n          </div>\n        </div>\n\n        {timeRotation[timerIdx].state === \"break\" && (\n          <iframe\n            title=\"2048 game\"\n            id=\"iframe1\"\n            src=\"https://www.mathsisfun.com/games/a/2048/index.html\"\n            scrolling=\"no\"\n            style={{\n              marginTop: \"72px\",\n              maxWidth: \"400px\",\n              height: \"600px\",\n              overflow: \"hidden\",\n              display: \"block\",\n              border: \"none\",\n              padding: \"32px\",\n              borderRadius: \"26px\",\n              backgroundColor: \"rgba(255, 255, 255, 1)\",\n            }}\n          ></iframe>\n        )}\n      </div>\n    </View>\n  );\n};\n\nconst styles = {\n  button: {\n    color: \"#7389AE\",\n    backgroundColor: \"#fff\",\n    outline: \"none\",\n    border: \"none\",\n    borderRadius: \"16px\",\n    padding: \"16px 8px\",\n    marginBottom: \"16px\",\n    \"font-size\": \"36px\",\n    \"font-family\": \"Inter\",\n    \"font-weight\": \"bold\",\n    width: \"400px\",\n  },\n  parent: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    padding: \"0px\",\n    width: \"100%\",\n    minHeight: \"100vh\",\n  },\n  main: {\n    margin: \"24px 0px\",\n    height: \"312px\",\n    display: \"flex\",\n    flexDirection: \"row\",\n  },\n  cardMain: {\n    display: \"flex\",\n    \"flex-direction\": \"column\",\n    \"justify-content\": \"center\",\n    \"align-items\": \"center\",\n    padding: \"160px 40px 40px\",\n\n    position: \"static\",\n    width: \"708px\",\n    minHeight: \"112px\",\n    left: \"0px\",\n    top: \"0px\",\n    background: \"#FFF\",\n    margin: \"0 24px\",\n  },\n  header: {\n    \"font-family\": \"Inter\",\n    \"font-style\": \"normal\",\n    \"font-weight\": \"bold\",\n    \"font-size\": \"40px\",\n    \"line-height\": \"48px\",\n    color: \"#0D1A26\",\n    padding: 0,\n    margin: \"16px 0px\",\n    position: \"static\",\n    width: \"708px\",\n    height: \"48px\",\n    left: \"40px\",\n    top: \"148px\",\n  },\n  text: {\n    \"font-family\": \"Inter\",\n    \"font-style\": \"normal\",\n    \"font-weight\": \"normal\",\n    \"font-size\": \"16px\",\n    \"line-height\": \"24px\",\n    \"letter-spacing\": \"0.01em\",\n    color: \"#304050\",\n    margin: 0,\n    marginBottom: \"10px\",\n    padding: 0,\n    position: \"static\",\n    width: \"708px\",\n    height: \"72px\",\n    left: \"40px\",\n    top: \"212px\",\n  },\n  cardContent: {},\n};\n\nexport default TimerPage;\n","/Users/angelinadeo/thehacktrical/NYUhack/src/colors.js",["104"],[],"export default {\n    background: \"#7389AE\",\n    secondary: \"#FFFFFF\",\n    text: \"#000000\",\n}","/Users/angelinadeo/thehacktrical/NYUhack/src/util/demo.js",["105","106","107","108","109","110","111","112"],[],"import \"@tensorflow/tfjs-core\";\nimport \"@tensorflow/tfjs-converter\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { draw } from \"./mask\";\nimport {\n  getDistance,\n  getAngle,\n  overallXAngle,\n  overallYAngle,\n  averageAngles,\n} from \"./analyzePoints\";\n\nconst Demo = (props) => {\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [frames, setFrames] = useState(0);\n  const [tog, setTog] = useState(false);\n  const [first, setFirst] = useState(true);\n  const [done, setDone] = useState(false);\n  const [loaded, setLoaded] = useState(false);\n  const [model, setModel] = useState(null);\n\n  const [dist, setDist] = useState(0);\n  const [xAngle, setXAngle] = useState(0);\n  const [yAngle, setYAngle] = useState(0);\n  const [overallAngle, setOverallAngle] = useState(0);\n  const [angleMeasures, setAngleMeasures] = useState([]);\n  const [focused, setFocused] = useState(true);\n\n  const loop = true;\n  const consoleOuput = false;\n\n  const runPredict = async () => {\n    if (consoleOuput) {\n      console.log(\"loading model\");\n    }\n    setModel(\n      await faceLandmarksDetection.load(\n        faceLandmarksDetection.SupportedPackages.mediapipeFacemesh\n      )\n    );\n    setLoaded(true);\n    detect(model);\n  };\n  const detect = async (model) => {\n    const t0 = new Date().getTime();\n    if (videoRef.current) {\n      const webcamCurrent = videoRef.current;\n      const videoWidth = webcamCurrent.video.videoWidth;\n      const videoHeight = webcamCurrent.video.videoHeight;\n      // go next step only when the video is completely uploaded.\n      if (webcamCurrent.video.readyState === 4) {\n        if (first) {\n          setFirst(false);\n          canvasRef.current.width = videoWidth;\n          canvasRef.current.height = videoHeight;\n        }\n        const video = webcamCurrent.video;\n        const predictions = await model.estimateFaces({\n          input: video,\n        });\n        if (predictions.length) {\n          if (consoleOuput) {\n            console.log(predictions);\n          }\n          if (!loop) {\n            setDone(true);\n          }\n          const ctx = canvasRef.current.getContext(\"2d\");\n          requestAnimationFrame(() => {\n            if (consoleOuput) {\n              console.log(\"drawing\");\n            }\n            draw(predictions, ctx, videoWidth, videoHeight);\n            setDist(getDistance(predictions));\n            const { xAngle, yAngle } = getAngle(predictions);\n            setXAngle(xAngle);\n            setYAngle(yAngle);\n            setAngleMeasures((prev) => {\n              const msrs = [...prev];\n              if (msrs.length >= 10) {\n                msrs.splice(0, 1);\n              }\n              msrs.push({\n                x: overallXAngle(predictions),\n                y: overallYAngle(predictions),\n              });\n              setOverallAngle(averageAngles(msrs));\n              return msrs;\n            });\n            setFocused(isFocused());\n          });\n\n          const t1 = new Date().getTime();\n          setFrames(1 / ((t1 - t0) / 1000));\n          //detect(model)\n        }\n      }\n    }\n    setTog(!tog);\n  };\n  useEffect(() => {\n    if (!done) {\n      if (model === null) {\n        runPredict();\n      } else {\n        detect(model);\n      }\n    }\n  }, [videoRef, tog]);\n\n  useEffect(() => {\n    props.focusChange(focused);\n  }, [focused]);\n\n  const isFocused = () => {\n    console.log(overallAngle.y);\n    return Math.abs(overallAngle.x) < 25 && Math.abs(overallAngle.y) < 30;\n  };\n\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        background: \"transparent\",\n        top: 0,\n        left: 0,\n      }} \n    >\n      <Webcam\n        id=\"video\"\n        ref={videoRef}\n        style={{ opacity: 0, position: \"absolute\" }}\n      ></Webcam>\n      <canvas ref={canvasRef} />\n      <div\n        style={{\n          position: \"fixed\",\n          top: ((overallAngle.y - 20) / -40) * window.innerHeight,\n          left: ((overallAngle.x - 20) / -40) * window.innerWidth,\n          height: 100,\n          width: 100,\n          borderRadius: 50,\n          backgroundColor: \"rgba(207, 207, 196, 0.2)\",\n          zIndex: 1,\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Demo;\n","/Users/angelinadeo/thehacktrical/NYUhack/src/util/mask.js",["113","114","115","116","117","118","119","120","121"],[],"// mask.ts\n\nimport { AnnotatedPrediction } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh\";\nimport {\n  Coord2D,\n  Coords3D,\n} from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util\";\nimport { getEyeAngle, getAngle } from \"./analyzePoints\";\n\nconst facePoints = {\n  leftEye: [\n    263, 249, 390, 373, 374, 380, 381, 382, 263, 466, 388, 387, 386, 385, 384,\n    398, 263,\n  ],\n  leftIris: [474, 475, 476, 477, 474],\n  leftEyeBrow: [276, 283, 282, 295, 300, 293, 334, 296, 276],\n  rightEye: [\n    33, 7, 163, 144, 145, 153, 154, 155, 33, 246, 161, 160, 159, 158, 157, 173,\n    33,\n  ],\n  rightIris: [469, 470, 471, 472, 469],\n  rightEyeBrow: [46, 53, 52, 65, 70, 63, 105, 66, 46],\n  lips: [\n    61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 61, 185, 40, 39, 37, 0, 267,\n    269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 78, 191, 80, 81,\n    82, 13, 312, 311, 310, 415, 61,\n  ],\n  faceOval: [\n    10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379,\n    378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127,\n    162, 21, 54, 103, 67, 109, 10,\n  ],\n};\n\nconst annotationKeys = [\n  \"silhouette\",\n  \"lipsUpperOuter\",\n  \"lipsLowerOuter\",\n  \"lipsUpperInner\",\n  \"lipsLowerInner\",\n  \"rightEyeUpper0\",\n  \"rightEyeLower0\",\n  \"rightEyeUpper1\",\n  \"rightEyeLower1\",\n  \"rightEyeUpper2\",\n  \"rightEyeLower2\",\n  \"rightEyeLower3\",\n  \"rightEyebrowUpper\",\n  \"rightEyebrowLower\",\n  \"rightEyeIris\",\n  \"leftEyeUpper0\",\n  \"leftEyeLower0\",\n  \"leftEyeUpper1\",\n  \"leftEyeLower1\",\n  \"leftEyeUpper2\",\n  \"leftEyeLower2\",\n  \"leftEyeLower3\",\n  \"leftEyebrowUpper\",\n  \"leftEyebrowLower\",\n  \"leftEyeIris\",\n  \"midwayBetweenEyes\",\n  \"noseTip\",\n  \"noseBottom\",\n  \"noseRightCorner\",\n  \"noseLeftCorner\",\n  \"rightCheek\",\n  \"leftCheek\",\n];\n\nconst drawMask = (ctx, keypoints) => {\n  Object.keys(facePoints).forEach((key) => {\n    const points = facePoints[key];\n    ctx.beginPath();\n    if (key == \"leftIris\") {\n      ctx.strokeStyle = \"transparent\";\n      ctx.fillStyle = \"white\";\n      const { leftIris, leftEye } = getEyeAngle({ scaledMesh: keypoints });\n      console.log(`irisX: ${leftIris.angleX}`);\n      ctx.fillRect(leftIris.x - 2.5, leftIris.y - 2.5, 5, 5);\n    } else if (key == \"rightIris\") {\n      ctx.strokeStyle = \"transparent\";\n      ctx.fillStyle = \"white\";\n      const { rightIris } = getEyeAngle({ scaledMesh: keypoints });\n      ctx.fillRect(rightIris.x - 2.5, rightIris.y - 2.5, 5, 5);\n    } else if (key == \"faceOval\") {\n      const { rightEye, rightIris, leftEye, leftIris } = getEyeAngle({\n        scaledMesh: keypoints,\n      });\n      ctx.strokeStyle = \"white\";\n      const newPointRight = {};\n      newPointRight.x = (rightIris.x - rightEye.x) * 10;\n      newPointRight.y = (rightIris.y - rightEye.y) * 10;\n      const newPointLeft = {};\n      newPointLeft.x = (leftIris.x - leftEye.x) * 10;\n      newPointLeft.y = (leftIris.y - leftEye.y) * 10;\n      const newPoint = {\n        x1: (rightEye.x + leftEye.x) / 2,\n        y1: (rightEye.y + leftEye.y) / 2,\n      };\n      newPoint.x2 = newPoint.x1 + (newPointRight.x + newPointLeft.x) / 2;\n      newPoint.y2 = newPoint.y1 + (newPointRight.y + newPointLeft.y) / 2;\n\n      ctx.beginPath();\n      ctx.moveTo(newPoint.x1, newPoint.y1);\n      ctx.lineTo(newPoint.x2, newPoint.y2);\n      ctx.closePath();\n      ctx.stroke();\n\n      const newPoint2 = {\n        x1: (rightEye.x + leftEye.x) / 2,\n        y1: (rightEye.y + leftEye.y) / 2 - (rightEye.x - leftEye.x) / 2,\n      };\n\n      ctx.strokeStyle = \"white\";\n      const { xAngle, yAngle } = getAngle([{ scaledMesh: keypoints }]);\n\n      newPoint2.x2 = newPoint2.x1 + xAngle;\n      newPoint2.y2 = newPoint2.y1 - yAngle;\n      ctx.beginPath();\n      ctx.moveTo(newPoint2.x1, newPoint2.y1);\n      ctx.lineTo(newPoint2.x2, newPoint2.y2);\n      ctx.closePath();\n      ctx.stroke();\n    } else ctx.strokeStyle = \"white\";\n    ctx.closePath();\n    ctx.stroke();\n    ctx.fillStyle = \"white\";\n    ctx.beginPath();\n    if (true) {\n      ctx.moveTo(points[0][0], points[0][1]);\n      for (let i = 1; i < points.length; i++) {\n        ctx.lineTo(keypoints[points[i]][0], keypoints[points[i]][1]);\n      }\n      ctx.closePath();\n    }\n    ctx.stroke();\n  });\n};\n\nexport const draw = (predictions, ctx, width, height) => {\n  if (predictions.length > 0) {\n    predictions.forEach((prediction) => {\n      const keypoints = prediction.scaledMesh;\n      const annotations = prediction.annotations;\n\n      ctx.clearRect(0, 0, width, height);\n      ctx.fillStyle = \"black\";\n      ctx.save();\n      drawMask(ctx, keypoints);\n      ctx.restore();\n    });\n  }\n};\n","/Users/angelinadeo/thehacktrical/NYUhack/src/util/analyzePoints.js",["122","123","124"],[],"const eyeCorners = {\n    leftEar: 263,\n    rightEar: 33,\n    leftNose: 382,\n    rightNose: 155,\n  };\n  \n  const lipChinLeft = 365;\n  const lipChinRight = 150;\n  const faceTop = 10;\n  const faceBottom = 152;\n  \n  const dist = (p1, p2) => {\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n  };\n  \n  const avgPoints = (p1, p2) => {\n    return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n  };\n  \n  export const getDistance = (prediction) => {\n    const keypoints = prediction[0].scaledMesh;\n  \n    /*\n    const x_avg =\n      keypoints.map((k) => k[0]).reduce((a, b) => a + b, 0) / keypoints.length;\n    const y_avg =\n      keypoints.map((k) => k[1]).reduce((a, b) => a + b, 0) / keypoints.length;\n    const center_point = [x_avg, y_avg];\n  \n    let total = 0;\n    let n = 0;\n  \n    keypoints.forEach((k) => {\n      n += 1;\n      total += dist(k, center_point);\n    });\n  \n    return (n / total) * 100;\n    */\n  \n    return (\n      1000 /\n      dist(\n        avgPoints(keypoints[eyeCorners.leftEar], keypoints[eyeCorners.leftNose]),\n        avgPoints(keypoints[eyeCorners.rightEar], keypoints[eyeCorners.rightNose])\n      )\n    );\n  };\n  \n  export const averageAngles = (measures) => {\n    var x = 0;\n    var y = 0;\n    measures.forEach((msr) => {\n      x += msr.x;\n      y += msr.y;\n    });\n    return { x: x / measures.length, y: y / measures.length };\n  };\n  \n  export const overallXAngle = (prediction) => {\n    const { xAngle, yAngle } = getAngle(prediction);\n    const coords = getEyeAngle(prediction[0]);\n    const xEyeAngle = (coords.leftIris.angleX + coords.rightIris.angleX) / 2 - 2;\n    const eyeScalar = 4;\n  \n    console.log(\"xFaceAngle: \" + xAngle);\n    console.log(\"xEyeAngle: \" + xEyeAngle);\n  \n    return xAngle + eyeScalar * xEyeAngle;\n  };\n  \n  export const overallYAngle = (prediction) => {\n    const { xAngle, yAngle } = getAngle(prediction);\n    const coords = getEyeAngle(prediction[0]);\n    const width = (coords.leftEye.width + coords.rightEye.width) / 2;\n    const height = (coords.leftEye.height + coords.rightEye.height) / 2;\n    const yEyeAngle =\n      (coords.leftIris.angleY + coords.rightIris.angleY) / 2 / (height / width);\n    const eyeScalar = 5;\n  \n    console.log(\"xFaceAngle: \" + yAngle);\n    console.log(\"xEyeAngle: \" + yEyeAngle);\n  \n    return yAngle;\n  };\n  \n  export const getAngle = (prediction) => {\n    const keypoints = prediction[0].scaledMesh;\n  \n    const est1 =\n      keypoints[eyeCorners.leftEar][2] - keypoints[eyeCorners.rightEar][2];\n    const est2 =\n      keypoints[eyeCorners.leftNose][2] - keypoints[eyeCorners.rightNose][2];\n    const est3 = keypoints[lipChinLeft][2] - keypoints[lipChinRight][2];\n  \n    const xAngle = (2 * (est1 + est2 + est3)) / 3;\n    const yAngle = keypoints[faceTop][2] - keypoints[faceBottom][2] + 30;\n  \n    return { xAngle, yAngle };\n  };\n  \n  const irises = {\n    rightIris: [474, 475, 476, 477],\n    leftIris: [469, 470, 471, 472],\n    rightEye: [\n      33, 7, 163, 144, 145, 153, 154, 155, 33, 246, 161, 160, 159, 158, 157, 173,\n      33,\n    ],\n    leftEye: [\n      263, 249, 390, 373, 374, 380, 381, 382, 263, 466, 388, 387, 386, 385, 384,\n      398, 263,\n    ],\n  };\n  \n  export const getEyeAngle = (prediction) => {\n    const keypoints = prediction.scaledMesh;\n    const hFOV = 35;\n    const vFOV = 25;\n  \n    var leftIrisX = 0;\n    var leftIrisY = 0;\n    var leftIrisZ = 0;\n    irises.leftIris.forEach((pt) => {\n      leftIrisX += keypoints[pt][0];\n      leftIrisY += keypoints[pt][1];\n      leftIrisZ += keypoints[pt][2];\n    });\n  \n    var rightIrisX = 0;\n    var rightIrisY = 0;\n    var rightIrisZ = 0;\n    irises.rightIris.forEach((pt) => {\n      rightIrisX += keypoints[pt][0];\n      rightIrisY += keypoints[pt][1];\n      rightIrisZ += keypoints[pt][2];\n    });\n  \n    var leftEyeMax = 0;\n    var leftEyeMin = 1000;\n    irises.leftEye.forEach((pt) => {\n      if (keypoints[pt][1] > leftEyeMax) leftEyeMax = keypoints[pt][1];\n      if (keypoints[pt][1] < leftEyeMin) leftEyeMin = keypoints[pt][1];\n    });\n  \n    var leftEye = {\n      x:\n        (keypoints[eyeCorners.leftEar][0] + keypoints[eyeCorners.leftNose][0]) /\n        2,\n      y: leftEyeMin + (leftEyeMax - leftEyeMin) / 2,\n      z:\n        (keypoints[eyeCorners.leftEar][2] + keypoints[eyeCorners.leftNose][2]) /\n        2,\n      width: Math.abs(\n        keypoints[eyeCorners.leftEar][0] - keypoints[eyeCorners.leftNose][0]\n      ),\n      height: leftEyeMax - leftEyeMin,\n    };\n   \n    var rightEyeMax = 0;\n    var rightEyeMin = 1000;\n    irises.rightEye.forEach((pt) => {\n      if (keypoints[pt][1] > rightEyeMax) rightEyeMax = keypoints[pt][1];\n      if (keypoints[pt][1] < rightEyeMin) rightEyeMin = keypoints[pt][1];\n    });\n  \n    var rightEye = {\n      x:\n        (keypoints[eyeCorners.rightEar][0] + keypoints[eyeCorners.rightNose][0]) /\n        2,\n      y: rightEyeMin + (rightEyeMax - rightEyeMin) / 2,\n      z:\n        (keypoints[eyeCorners.rightEar][2] + keypoints[eyeCorners.rightNose][2]) /\n        2,\n      width: Math.abs(\n        keypoints[eyeCorners.rightEar][0] - keypoints[eyeCorners.rightNose][0]\n      ),\n      height: rightEyeMax - rightEyeMin,\n    };\n  \n    const coords = {\n      leftIris: { x: leftIrisX / 4, y: leftIrisY / 4, z: leftIrisZ / 4 },\n      rightIris: { x: rightIrisX / 4, y: rightIrisY / 4, z: rightIrisZ / 4 },\n      leftEye,\n      rightEye,\n    };\n  \n    // left iris angle\n    const leftAngleX =\n      ((coords.leftIris.x - coords.leftEye.x) / (coords.leftEye.width / 2)) *\n      hFOV;\n    //const leftAngleX = coords.leftIris.x-coords.leftEye.x\n    const leftAngleY =\n      ((coords.leftIris.y - coords.leftEye.y) / (coords.leftEye.height / 2)) *\n      vFOV;\n    coords.leftIris.angleX = leftAngleX;\n    coords.leftIris.angleY = leftAngleY;\n  \n    // right iris angle\n    const rightAngleX =\n      ((coords.rightIris.x - coords.rightEye.x) / (coords.rightEye.width / 2)) *\n      hFOV;\n    //const rightAngleX = coords.rightIris.x-coords.rightEye.x\n    const rightAngleY =\n      ((coords.rightIris.y - coords.rightEye.y) / (coords.rightEye.height / 2)) *\n      vFOV;\n    coords.rightIris.angleX = rightAngleX;\n    coords.rightIris.angleY = rightAngleY;\n  \n    return coords;\n  };\n  ",["125","126"],"/Users/angelinadeo/thehacktrical/NYUhack/src/Components/NavBar.js",["127","128"],[],{"ruleId":"129","replacedBy":"130"},{"ruleId":"131","replacedBy":"132"},{"ruleId":"133","severity":1,"message":"134","line":2,"column":8,"nodeType":"135","messageId":"136","endLine":2,"endColumn":13},{"ruleId":"133","severity":1,"message":"137","line":4,"column":8,"nodeType":"135","messageId":"136","endLine":4,"endColumn":21},{"ruleId":"133","severity":1,"message":"138","line":4,"column":10,"nodeType":"135","messageId":"136","endLine":4,"endColumn":14},{"ruleId":"133","severity":1,"message":"139","line":4,"column":16,"nodeType":"135","messageId":"136","endLine":4,"endColumn":20},{"ruleId":"140","severity":1,"message":"141","line":92,"column":6,"nodeType":"142","endLine":92,"endColumn":15,"suggestions":"143"},{"ruleId":"140","severity":1,"message":"141","line":112,"column":6,"nodeType":"142","endLine":112,"endColumn":16,"suggestions":"144"},{"ruleId":"140","severity":1,"message":"145","line":119,"column":6,"nodeType":"142","endLine":119,"endColumn":17,"suggestions":"146"},{"ruleId":"147","severity":1,"message":"148","line":1,"column":1,"nodeType":"149","endLine":5,"endColumn":2},{"ruleId":"133","severity":1,"message":"150","line":19,"column":10,"nodeType":"135","messageId":"136","endLine":19,"endColumn":16},{"ruleId":"133","severity":1,"message":"151","line":23,"column":10,"nodeType":"135","messageId":"136","endLine":23,"endColumn":16},{"ruleId":"133","severity":1,"message":"152","line":26,"column":10,"nodeType":"135","messageId":"136","endLine":26,"endColumn":14},{"ruleId":"133","severity":1,"message":"153","line":27,"column":10,"nodeType":"135","messageId":"136","endLine":27,"endColumn":16},{"ruleId":"133","severity":1,"message":"154","line":28,"column":10,"nodeType":"135","messageId":"136","endLine":28,"endColumn":16},{"ruleId":"133","severity":1,"message":"155","line":30,"column":10,"nodeType":"135","messageId":"136","endLine":30,"endColumn":23},{"ruleId":"140","severity":1,"message":"156","line":113,"column":6,"nodeType":"142","endLine":113,"endColumn":21,"suggestions":"157"},{"ruleId":"140","severity":1,"message":"158","line":117,"column":6,"nodeType":"142","endLine":117,"endColumn":15,"suggestions":"159"},{"ruleId":"133","severity":1,"message":"160","line":3,"column":10,"nodeType":"135","messageId":"136","endLine":3,"endColumn":29},{"ruleId":"133","severity":1,"message":"161","line":5,"column":3,"nodeType":"135","messageId":"136","endLine":5,"endColumn":10},{"ruleId":"133","severity":1,"message":"162","line":6,"column":3,"nodeType":"135","messageId":"136","endLine":6,"endColumn":11},{"ruleId":"133","severity":1,"message":"163","line":35,"column":7,"nodeType":"135","messageId":"136","endLine":35,"endColumn":21},{"ruleId":"164","severity":1,"message":"165","line":74,"column":13,"nodeType":"166","messageId":"167","endLine":74,"endColumn":15},{"ruleId":"133","severity":1,"message":"168","line":77,"column":25,"nodeType":"135","messageId":"136","endLine":77,"endColumn":32},{"ruleId":"164","severity":1,"message":"165","line":80,"column":20,"nodeType":"166","messageId":"167","endLine":80,"endColumn":22},{"ruleId":"164","severity":1,"message":"165","line":85,"column":20,"nodeType":"166","messageId":"167","endLine":85,"endColumn":22},{"ruleId":"133","severity":1,"message":"169","line":144,"column":13,"nodeType":"135","messageId":"136","endLine":144,"endColumn":24},{"ruleId":"133","severity":1,"message":"154","line":62,"column":21,"nodeType":"135","messageId":"136","endLine":62,"endColumn":27},{"ruleId":"133","severity":1,"message":"153","line":74,"column":13,"nodeType":"135","messageId":"136","endLine":74,"endColumn":19},{"ruleId":"133","severity":1,"message":"170","line":80,"column":11,"nodeType":"135","messageId":"136","endLine":80,"endColumn":20},{"ruleId":"129","replacedBy":"171"},{"ruleId":"131","replacedBy":"172"},{"ruleId":"133","severity":1,"message":"173","line":2,"column":8,"nodeType":"135","messageId":"136","endLine":2,"endColumn":14},{"ruleId":"133","severity":1,"message":"174","line":3,"column":10,"nodeType":"135","messageId":"136","endLine":3,"endColumn":31},"no-native-reassign",["175"],"no-negated-in-lhs",["176"],"no-unused-vars","'Timer' is defined but never used.","Identifier","unusedVar","'landingScreen' is defined but never used.","'Card' is defined but never used.","'Flex' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'focused' and 'started'. Either include them or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setFocusSwitchTimes' needs the current value of 'focused'.","ArrayExpression",["177"],["178"],"React Hook useEffect has a missing dependency: 'timerIdx'. Either include it or remove the dependency array.",["179"],"import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","'frames' is assigned a value but never used.","'loaded' is assigned a value but never used.","'dist' is assigned a value but never used.","'xAngle' is assigned a value but never used.","'yAngle' is assigned a value but never used.","'angleMeasures' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'detect', 'done', 'model', and 'runPredict'. Either include them or remove the dependency array.",["180"],"React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["181"],"'AnnotatedPrediction' is defined but never used.","'Coord2D' is defined but never used.","'Coords3D' is defined but never used.","'annotationKeys' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'leftEye' is assigned a value but never used.","'annotations' is assigned a value but never used.","'eyeScalar' is assigned a value but never used.",["175"],["176"],"'colors' is defined but never used.","'IconHourglassDisabled' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"182","fix":"183"},{"desc":"184","fix":"185"},{"desc":"186","fix":"187"},{"desc":"188","fix":"189"},{"desc":"190","fix":"191"},"Update the dependencies array to be: [focused, playing, started]",{"range":"192","text":"193"},"Update the dependencies array to be: [focused, started, timerIdx]",{"range":"194","text":"195"},"Update the dependencies array to be: [remaining, timerIdx]",{"range":"196","text":"197"},"Update the dependencies array to be: [videoRef, tog, done, model, runPredict, detect]",{"range":"198","text":"199"},"Update the dependencies array to be: [focused, props]",{"range":"200","text":"201"},[2812,2821],"[focused, playing, started]",[3312,3322],"[focused, started, timerIdx]",[3559,3570],"[remaining, timerIdx]",[3434,3449],"[videoRef, tog, done, model, runPredict, detect]",[3510,3519],"[focused, props]"]