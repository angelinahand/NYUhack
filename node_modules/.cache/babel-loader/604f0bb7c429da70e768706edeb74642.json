{"ast":null,"code":"// mask.ts\nimport { AnnotatedPrediction } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh\";\nimport { Coord2D, Coords3D } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util\";\nimport { getEyeAngle, getAngle } from \"./analyzePoints\";\nconst facePoints = {\n  leftEye: [263, 249, 390, 373, 374, 380, 381, 382, 263, 466, 388, 387, 386, 385, 384, 398, 263],\n  leftIris: [474, 475, 476, 477, 474],\n  leftEyeBrow: [276, 283, 282, 295, 300, 293, 334, 296, 276],\n  rightEye: [33, 7, 163, 144, 145, 153, 154, 155, 33, 246, 161, 160, 159, 158, 157, 173, 33],\n  rightIris: [469, 470, 471, 472, 469],\n  rightEyeBrow: [46, 53, 52, 65, 70, 63, 105, 66, 46],\n  lips: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 61],\n  faceOval: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10]\n};\nconst annotationKeys = [\"silhouette\", \"lipsUpperOuter\", \"lipsLowerOuter\", \"lipsUpperInner\", \"lipsLowerInner\", \"rightEyeUpper0\", \"rightEyeLower0\", \"rightEyeUpper1\", \"rightEyeLower1\", \"rightEyeUpper2\", \"rightEyeLower2\", \"rightEyeLower3\", \"rightEyebrowUpper\", \"rightEyebrowLower\", \"rightEyeIris\", \"leftEyeUpper0\", \"leftEyeLower0\", \"leftEyeUpper1\", \"leftEyeLower1\", \"leftEyeUpper2\", \"leftEyeLower2\", \"leftEyeLower3\", \"leftEyebrowUpper\", \"leftEyebrowLower\", \"leftEyeIris\", \"midwayBetweenEyes\", \"noseTip\", \"noseBottom\", \"noseRightCorner\", \"noseLeftCorner\", \"rightCheek\", \"leftCheek\"];\n\nconst drawMask = (ctx, keypoints) => {\n  Object.keys(facePoints).forEach(key => {\n    const points = facePoints[key];\n    ctx.beginPath();\n\n    if (key == \"leftIris\") {\n      ctx.strokeStyle = \"transparent\";\n      ctx.fillStyle = \"white\";\n      const {\n        leftIris,\n        leftEye\n      } = getEyeAngle({\n        scaledMesh: keypoints\n      });\n      console.log(`irisX: ${leftIris.angleX}`);\n      ctx.fillRect(leftIris.x - 2.5, leftIris.y - 2.5, 5, 5);\n    } else if (key == \"rightIris\") {\n      ctx.strokeStyle = \"transparent\";\n      ctx.fillStyle = \"white\";\n      const {\n        rightIris\n      } = getEyeAngle({\n        scaledMesh: keypoints\n      });\n      ctx.fillRect(rightIris.x - 2.5, rightIris.y - 2.5, 5, 5);\n    } else if (key == \"faceOval\") {\n      const {\n        rightEye,\n        rightIris,\n        leftEye,\n        leftIris\n      } = getEyeAngle({\n        scaledMesh: keypoints\n      });\n      ctx.strokeStyle = \"white\";\n      const newPointRight = {};\n      newPointRight.x = (rightIris.x - rightEye.x) * 10;\n      newPointRight.y = (rightIris.y - rightEye.y) * 10;\n      const newPointLeft = {};\n      newPointLeft.x = (leftIris.x - leftEye.x) * 10;\n      newPointLeft.y = (leftIris.y - leftEye.y) * 10;\n      const newPoint = {\n        x1: (rightEye.x + leftEye.x) / 2,\n        y1: (rightEye.y + leftEye.y) / 2\n      };\n      newPoint.x2 = newPoint.x1 + (newPointRight.x + newPointLeft.x) / 2;\n      newPoint.y2 = newPoint.y1 + (newPointRight.y + newPointLeft.y) / 2;\n      ctx.beginPath();\n      ctx.moveTo(newPoint.x1, newPoint.y1);\n      ctx.lineTo(newPoint.x2, newPoint.y2);\n      ctx.closePath();\n      ctx.stroke();\n      const newPoint2 = {\n        x1: (rightEye.x + leftEye.x) / 2,\n        y1: (rightEye.y + leftEye.y) / 2 - (rightEye.x - leftEye.x) / 2\n      };\n      ctx.strokeStyle = \"white\";\n      const {\n        xAngle,\n        yAngle\n      } = getAngle([{\n        scaledMesh: keypoints\n      }]);\n      newPoint2.x2 = newPoint2.x1 + xAngle;\n      newPoint2.y2 = newPoint2.y1 - yAngle;\n      ctx.beginPath();\n      ctx.moveTo(newPoint2.x1, newPoint2.y1);\n      ctx.lineTo(newPoint2.x2, newPoint2.y2);\n      ctx.closePath();\n      ctx.stroke();\n    } else ctx.strokeStyle = \"white\";\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.fillStyle = \"white\";\n    ctx.beginPath();\n\n    if (true) {\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (let i = 1; i < points.length; i++) {\n        ctx.lineTo(keypoints[points[i]][0], keypoints[points[i]][1]);\n      }\n\n      ctx.closePath();\n    }\n\n    ctx.stroke();\n  });\n};\n\nexport const draw = (predictions, ctx, width, height) => {\n  if (predictions.length > 0) {\n    predictions.forEach(prediction => {\n      const keypoints = prediction.scaledMesh;\n      const annotations = prediction.annotations;\n      ctx.clearRect(0, 0, width, height);\n      ctx.fillStyle = \"black\";\n      ctx.save();\n      drawMask(ctx, keypoints);\n      ctx.restore();\n    });\n  }\n};","map":{"version":3,"sources":["/Users/angelinadeo/thehacktrical/NYUhack/src/util/mask.js"],"names":["AnnotatedPrediction","Coord2D","Coords3D","getEyeAngle","getAngle","facePoints","leftEye","leftIris","leftEyeBrow","rightEye","rightIris","rightEyeBrow","lips","faceOval","annotationKeys","drawMask","ctx","keypoints","Object","keys","forEach","key","points","beginPath","strokeStyle","fillStyle","scaledMesh","console","log","angleX","fillRect","x","y","newPointRight","newPointLeft","newPoint","x1","y1","x2","y2","moveTo","lineTo","closePath","stroke","newPoint2","xAngle","yAngle","i","length","draw","predictions","width","height","prediction","annotations","clearRect","save","restore"],"mappings":"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","sourcesContent":["// mask.ts\n\nimport { AnnotatedPrediction } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh\";\nimport {\n  Coord2D,\n  Coords3D,\n} from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/util\";\nimport { getEyeAngle, getAngle } from \"./analyzePoints\";\n\nconst facePoints = {\n  leftEye: [\n    263, 249, 390, 373, 374, 380, 381, 382, 263, 466, 388, 387, 386, 385, 384,\n    398, 263,\n  ],\n  leftIris: [474, 475, 476, 477, 474],\n  leftEyeBrow: [276, 283, 282, 295, 300, 293, 334, 296, 276],\n  rightEye: [\n    33, 7, 163, 144, 145, 153, 154, 155, 33, 246, 161, 160, 159, 158, 157, 173,\n    33,\n  ],\n  rightIris: [469, 470, 471, 472, 469],\n  rightEyeBrow: [46, 53, 52, 65, 70, 63, 105, 66, 46],\n  lips: [\n    61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 61, 185, 40, 39, 37, 0, 267,\n    269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 78, 191, 80, 81,\n    82, 13, 312, 311, 310, 415, 61,\n  ],\n  faceOval: [\n    10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379,\n    378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127,\n    162, 21, 54, 103, 67, 109, 10,\n  ],\n};\n\nconst annotationKeys = [\n  \"silhouette\",\n  \"lipsUpperOuter\",\n  \"lipsLowerOuter\",\n  \"lipsUpperInner\",\n  \"lipsLowerInner\",\n  \"rightEyeUpper0\",\n  \"rightEyeLower0\",\n  \"rightEyeUpper1\",\n  \"rightEyeLower1\",\n  \"rightEyeUpper2\",\n  \"rightEyeLower2\",\n  \"rightEyeLower3\",\n  \"rightEyebrowUpper\",\n  \"rightEyebrowLower\",\n  \"rightEyeIris\",\n  \"leftEyeUpper0\",\n  \"leftEyeLower0\",\n  \"leftEyeUpper1\",\n  \"leftEyeLower1\",\n  \"leftEyeUpper2\",\n  \"leftEyeLower2\",\n  \"leftEyeLower3\",\n  \"leftEyebrowUpper\",\n  \"leftEyebrowLower\",\n  \"leftEyeIris\",\n  \"midwayBetweenEyes\",\n  \"noseTip\",\n  \"noseBottom\",\n  \"noseRightCorner\",\n  \"noseLeftCorner\",\n  \"rightCheek\",\n  \"leftCheek\",\n];\n\nconst drawMask = (ctx, keypoints) => {\n  Object.keys(facePoints).forEach((key) => {\n    const points = facePoints[key];\n    ctx.beginPath();\n    if (key == \"leftIris\") {\n      ctx.strokeStyle = \"transparent\";\n      ctx.fillStyle = \"white\";\n      const { leftIris, leftEye } = getEyeAngle({ scaledMesh: keypoints });\n      console.log(`irisX: ${leftIris.angleX}`);\n      ctx.fillRect(leftIris.x - 2.5, leftIris.y - 2.5, 5, 5);\n    } else if (key == \"rightIris\") {\n      ctx.strokeStyle = \"transparent\";\n      ctx.fillStyle = \"white\";\n      const { rightIris } = getEyeAngle({ scaledMesh: keypoints });\n      ctx.fillRect(rightIris.x - 2.5, rightIris.y - 2.5, 5, 5);\n    } else if (key == \"faceOval\") {\n      const { rightEye, rightIris, leftEye, leftIris } = getEyeAngle({\n        scaledMesh: keypoints,\n      });\n      ctx.strokeStyle = \"white\";\n      const newPointRight = {};\n      newPointRight.x = (rightIris.x - rightEye.x) * 10;\n      newPointRight.y = (rightIris.y - rightEye.y) * 10;\n      const newPointLeft = {};\n      newPointLeft.x = (leftIris.x - leftEye.x) * 10;\n      newPointLeft.y = (leftIris.y - leftEye.y) * 10;\n      const newPoint = {\n        x1: (rightEye.x + leftEye.x) / 2,\n        y1: (rightEye.y + leftEye.y) / 2,\n      };\n      newPoint.x2 = newPoint.x1 + (newPointRight.x + newPointLeft.x) / 2;\n      newPoint.y2 = newPoint.y1 + (newPointRight.y + newPointLeft.y) / 2;\n\n      ctx.beginPath();\n      ctx.moveTo(newPoint.x1, newPoint.y1);\n      ctx.lineTo(newPoint.x2, newPoint.y2);\n      ctx.closePath();\n      ctx.stroke();\n\n      const newPoint2 = {\n        x1: (rightEye.x + leftEye.x) / 2,\n        y1: (rightEye.y + leftEye.y) / 2 - (rightEye.x - leftEye.x) / 2,\n      };\n\n      ctx.strokeStyle = \"white\";\n      const { xAngle, yAngle } = getAngle([{ scaledMesh: keypoints }]);\n\n      newPoint2.x2 = newPoint2.x1 + xAngle;\n      newPoint2.y2 = newPoint2.y1 - yAngle;\n      ctx.beginPath();\n      ctx.moveTo(newPoint2.x1, newPoint2.y1);\n      ctx.lineTo(newPoint2.x2, newPoint2.y2);\n      ctx.closePath();\n      ctx.stroke();\n    } else ctx.strokeStyle = \"white\";\n    ctx.closePath();\n    ctx.stroke();\n    ctx.fillStyle = \"white\";\n    ctx.beginPath();\n    if (true) {\n      ctx.moveTo(points[0][0], points[0][1]);\n      for (let i = 1; i < points.length; i++) {\n        ctx.lineTo(keypoints[points[i]][0], keypoints[points[i]][1]);\n      }\n      ctx.closePath();\n    }\n    ctx.stroke();\n  });\n};\n\nexport const draw = (predictions, ctx, width, height) => {\n  if (predictions.length > 0) {\n    predictions.forEach((prediction) => {\n      const keypoints = prediction.scaledMesh;\n      const annotations = prediction.annotations;\n\n      ctx.clearRect(0, 0, width, height);\n      ctx.fillStyle = \"black\";\n      ctx.save();\n      drawMask(ctx, keypoints);\n      ctx.restore();\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}