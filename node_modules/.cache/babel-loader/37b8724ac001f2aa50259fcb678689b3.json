{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar blazeface = require(\"@tensorflow-models/blazeface\");\n\nvar tfconv = require(\"@tensorflow/tfjs-converter\");\n\nvar tf = require(\"@tensorflow/tfjs-core\");\n\nvar keypoints_1 = require(\"./keypoints\");\n\nvar pipeline_1 = require(\"./pipeline\");\n\nvar uv_coords_1 = require(\"./uv_coords\");\n\nvar FACEMESH_GRAPHMODEL_PATH = 'https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1';\nvar IRIS_GRAPHMODEL_PATH = 'https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2';\nvar MESH_MODEL_INPUT_WIDTH = 192;\nvar MESH_MODEL_INPUT_HEIGHT = 192;\nvar PREDICTION_VALUES = 'MediaPipePredictionValues';\nvar PREDICTION_TENSORS = 'MediaPipePredictionTensors';\n/**\n * Load the model.\n *\n * @param options - a configuration object with the following properties:\n *  - `maxContinuousChecks` How many frames to go without running the bounding\n * box detector. Only relevant if maxFaces > 1. Defaults to 5.\n *  - `detectionConfidence` Threshold for discarding a prediction. Defaults to\n * 0.9.\n *  - `maxFaces` The maximum number of faces detected in the input. Should be\n * set to the minimum number for performance. Defaults to 10.\n *  - `iouThreshold` A float representing the threshold for deciding whether\n * boxes overlap too much in non-maximum suppression. Must be between [0, 1].\n * Defaults to 0.3.\n *  - `scoreThreshold` A threshold for deciding when to remove boxes based\n * on score in non-maximum suppression. Defaults to 0.75.\n *  - `shouldLoadIrisModel` Whether to also load the iris detection model.\n * Defaults to true.\n *  - `modelUrl` Optional param for specifying a custom facemesh model url or\n * a `tf.io.IOHandler` object.\n *  - `detectorModelUrl` Optional param for specifying a custom blazeface model\n * url or a `tf.io.IOHandler` object.\n *  - `irisModelUrl` Optional param for specifying a custom iris model url or\n * a `tf.io.IOHandler` object.\n */\n\nfunction load(config) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, maxContinuousChecks, _b, detectionConfidence, _c, maxFaces, _d, iouThreshold, _e, scoreThreshold, _f, shouldLoadIrisModel, modelUrl, detectorModelUrl, irisModelUrl, models, faceMesh;\n\n    return __generator(this, function (_g) {\n      switch (_g.label) {\n        case 0:\n          _a = config.maxContinuousChecks, maxContinuousChecks = _a === void 0 ? 5 : _a, _b = config.detectionConfidence, detectionConfidence = _b === void 0 ? 0.9 : _b, _c = config.maxFaces, maxFaces = _c === void 0 ? 10 : _c, _d = config.iouThreshold, iouThreshold = _d === void 0 ? 0.3 : _d, _e = config.scoreThreshold, scoreThreshold = _e === void 0 ? 0.75 : _e, _f = config.shouldLoadIrisModel, shouldLoadIrisModel = _f === void 0 ? true : _f, modelUrl = config.modelUrl, detectorModelUrl = config.detectorModelUrl, irisModelUrl = config.irisModelUrl;\n          if (!shouldLoadIrisModel) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , Promise.all([loadDetectorModel(detectorModelUrl, maxFaces, iouThreshold, scoreThreshold), loadMeshModel(modelUrl), loadIrisModel(irisModelUrl)])];\n\n        case 1:\n          models = _g.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 2:\n          return [4\n          /*yield*/\n          , Promise.all([loadDetectorModel(detectorModelUrl, maxFaces, iouThreshold, scoreThreshold), loadMeshModel(modelUrl)])];\n\n        case 3:\n          models = _g.sent();\n          _g.label = 4;\n\n        case 4:\n          faceMesh = new FaceMesh(models[0], models[1], maxContinuousChecks, detectionConfidence, maxFaces, shouldLoadIrisModel ? models[2] : null);\n          return [2\n          /*return*/\n          , faceMesh];\n      }\n    });\n  });\n}\n\nexports.load = load;\n\nfunction loadDetectorModel(modelUrl, maxFaces, iouThreshold, scoreThreshold) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2\n      /*return*/\n      , blazeface.load({\n        modelUrl: modelUrl,\n        maxFaces: maxFaces,\n        iouThreshold: iouThreshold,\n        scoreThreshold: scoreThreshold\n      })];\n    });\n  });\n}\n\nfunction loadMeshModel(modelUrl) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      if (modelUrl != null) {\n        return [2\n        /*return*/\n        , tfconv.loadGraphModel(modelUrl)];\n      }\n\n      return [2\n      /*return*/\n      , tfconv.loadGraphModel(FACEMESH_GRAPHMODEL_PATH, {\n        fromTFHub: true\n      })];\n    });\n  });\n}\n\nfunction loadIrisModel(modelUrl) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      if (modelUrl != null) {\n        return [2\n        /*return*/\n        , tfconv.loadGraphModel(modelUrl)];\n      }\n\n      return [2\n      /*return*/\n      , tfconv.loadGraphModel(IRIS_GRAPHMODEL_PATH, {\n        fromTFHub: true\n      })];\n    });\n  });\n}\n\nfunction getInputTensorDimensions(input) {\n  return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] : [input.height, input.width];\n}\n\nfunction flipFaceHorizontal(face, imageWidth) {\n  if (face.mesh instanceof tf.Tensor) {\n    var _a = tf.tidy(function () {\n      var subtractBasis = tf.tensor1d([imageWidth - 1, 0, 0]);\n      var multiplyBasis = tf.tensor1d([1, -1, 1]);\n      return tf.tidy(function () {\n        return [tf.concat([tf.sub(imageWidth - 1, tf.slice(face.boundingBox.topLeft, 0, 1)), tf.slice(face.boundingBox.topLeft, 1, 1)]), tf.concat([tf.sub(imageWidth - 1, tf.slice(face.boundingBox.bottomRight, 0, 1)), tf.slice(face.boundingBox.bottomRight, 1, 1)]), tf.mul(tf.sub(subtractBasis, face.mesh), multiplyBasis), tf.mul(tf.sub(subtractBasis, face.scaledMesh), multiplyBasis)];\n      });\n    }),\n        topLeft = _a[0],\n        bottomRight = _a[1],\n        mesh = _a[2],\n        scaledMesh = _a[3];\n\n    return Object.assign({}, face, {\n      boundingBox: {\n        topLeft: topLeft,\n        bottomRight: bottomRight\n      },\n      mesh: mesh,\n      scaledMesh: scaledMesh\n    });\n  }\n\n  return Object.assign({}, face, {\n    boundingBox: {\n      topLeft: [imageWidth - 1 - face.boundingBox.topLeft[0], face.boundingBox.topLeft[1]],\n      bottomRight: [imageWidth - 1 - face.boundingBox.bottomRight[0], face.boundingBox.bottomRight[1]]\n    },\n    mesh: face.mesh.map(function (coord) {\n      var flippedCoord = coord.slice(0);\n      flippedCoord[0] = imageWidth - 1 - coord[0];\n      return flippedCoord;\n    }),\n    scaledMesh: face.scaledMesh.map(function (coord) {\n      var flippedCoord = coord.slice(0);\n      flippedCoord[0] = imageWidth - 1 - coord[0];\n      return flippedCoord;\n    })\n  });\n}\n\nvar FaceMesh =\n/** @class */\nfunction () {\n  function FaceMesh(blazeFace, blazeMeshModel, maxContinuousChecks, detectionConfidence, maxFaces, irisModel) {\n    this.kind = 'MediaPipeFaceMesh';\n    this.pipeline = new pipeline_1.Pipeline(blazeFace, blazeMeshModel, MESH_MODEL_INPUT_WIDTH, MESH_MODEL_INPUT_HEIGHT, maxContinuousChecks, maxFaces, irisModel);\n    this.detectionConfidence = detectionConfidence;\n  }\n\n  FaceMesh.getAnnotations = function () {\n    return keypoints_1.MESH_ANNOTATIONS;\n  };\n  /**\n   * Returns an array of UV coordinates for the 468 facial keypoint vertices in\n   * mesh_map.jpg. Can be used to map textures to the facial mesh.\n   */\n\n\n  FaceMesh.getUVCoords = function () {\n    return uv_coords_1.UV_COORDS;\n  };\n  /**\n   * Returns an array of faces in an image.\n   *\n   * @param input The image to classify. Can be a tensor, DOM element image,\n   * video, or canvas.\n   * @param returnTensors (defaults to `false`) Whether to return tensors as\n   * opposed to values.\n   * @param flipHorizontal Whether to flip/mirror the facial keypoints\n   * horizontally. Should be true for videos that are flipped by default (e.g.\n   * webcams).\n   * @param predictIrises\n   *\n   * @return An array of AnnotatedPrediction objects.\n   */\n\n\n  FaceMesh.prototype.estimateFaces = function (config) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, returnTensors, _b, flipHorizontal, _c, predictIrises, input, _d, width, image, predictions, savedWebglPackDepthwiseConvFlag;\n\n      var _this = this;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _a = config.returnTensors, returnTensors = _a === void 0 ? false : _a, _b = config.flipHorizontal, flipHorizontal = _b === void 0 ? false : _b, _c = config.predictIrises, predictIrises = _c === void 0 ? true : _c;\n            input = config.input;\n\n            if (predictIrises && this.pipeline.irisModel == null) {\n              throw new Error('The iris model was not loaded as part of facemesh. ' + 'Please initialize the model with ' + 'facemesh.load({shouldLoadIrisModel: true}).');\n            }\n\n            _d = getInputTensorDimensions(input), width = _d[1];\n            image = tf.tidy(function () {\n              if (!(input instanceof tf.Tensor)) {\n                input = tf.browser.fromPixels(input);\n              }\n\n              return tf.expandDims(tf.cast(input, 'float32'), 0);\n            });\n            if (!(tf.getBackend() === 'webgl')) return [3\n            /*break*/\n            , 2];\n            savedWebglPackDepthwiseConvFlag = tf.env().get('WEBGL_PACK_DEPTHWISECONV');\n            tf.env().set('WEBGL_PACK_DEPTHWISECONV', true);\n            return [4\n            /*yield*/\n            , this.pipeline.predict(image, predictIrises)];\n\n          case 1:\n            predictions = _e.sent();\n            tf.env().set('WEBGL_PACK_DEPTHWISECONV', savedWebglPackDepthwiseConvFlag);\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.pipeline.predict(image, predictIrises)];\n\n          case 3:\n            predictions = _e.sent();\n            _e.label = 4;\n\n          case 4:\n            image.dispose();\n\n            if (predictions != null && predictions.length > 0) {\n              return [2\n              /*return*/\n              , Promise.all(predictions.map(function (prediction, i) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var coords, scaledCoords, box, flag, tensorsToRead, tensorValues, flagValue, annotatedPrediction_1, _a, coordsArr, coordsArrScaled, annotatedPrediction, annotations, key;\n\n                  var _this = this;\n\n                  return __generator(this, function (_b) {\n                    switch (_b.label) {\n                      case 0:\n                        coords = prediction.coords, scaledCoords = prediction.scaledCoords, box = prediction.box, flag = prediction.flag;\n                        tensorsToRead = [flag];\n\n                        if (!returnTensors) {\n                          tensorsToRead = tensorsToRead.concat([coords, scaledCoords]);\n                        }\n\n                        return [4\n                        /*yield*/\n                        , Promise.all(tensorsToRead.map(function (d) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                              return [2\n                              /*return*/\n                              , d.array()];\n                            });\n                          });\n                        }))];\n\n                      case 1:\n                        tensorValues = _b.sent();\n                        flagValue = tensorValues[0];\n                        flag.dispose();\n\n                        if (flagValue < this.detectionConfidence) {\n                          this.pipeline.clearRegionOfInterest(i);\n                        }\n\n                        if (returnTensors) {\n                          annotatedPrediction_1 = {\n                            kind: PREDICTION_TENSORS,\n                            faceInViewConfidence: flagValue,\n                            mesh: coords,\n                            scaledMesh: scaledCoords,\n                            boundingBox: {\n                              topLeft: tf.tensor1d(box.startPoint),\n                              bottomRight: tf.tensor1d(box.endPoint)\n                            }\n                          };\n\n                          if (flipHorizontal) {\n                            return [2\n                            /*return*/\n                            , flipFaceHorizontal(annotatedPrediction_1, width)];\n                          }\n\n                          return [2\n                          /*return*/\n                          , annotatedPrediction_1];\n                        }\n\n                        _a = tensorValues.slice(1), coordsArr = _a[0], coordsArrScaled = _a[1];\n                        scaledCoords.dispose();\n                        coords.dispose();\n                        annotatedPrediction = {\n                          kind: PREDICTION_VALUES,\n                          faceInViewConfidence: flagValue,\n                          boundingBox: {\n                            topLeft: box.startPoint,\n                            bottomRight: box.endPoint\n                          },\n                          mesh: coordsArr,\n                          scaledMesh: coordsArrScaled\n                        };\n\n                        if (flipHorizontal) {\n                          annotatedPrediction = flipFaceHorizontal(annotatedPrediction, width);\n                        }\n\n                        annotations = {};\n\n                        for (key in keypoints_1.MESH_ANNOTATIONS) {\n                          if (predictIrises || key.includes('Iris') === false) {\n                            annotations[key] = keypoints_1.MESH_ANNOTATIONS[key].map(function (index) {\n                              return annotatedPrediction.scaledMesh[index];\n                            });\n                          }\n                        }\n\n                        annotatedPrediction['annotations'] = annotations;\n                        return [2\n                        /*return*/\n                        , annotatedPrediction];\n                    }\n                  });\n                });\n              }))];\n            }\n\n            return [2\n            /*return*/\n            , []];\n        }\n      });\n    });\n  };\n\n  return FaceMesh;\n}();","map":{"version":3,"mappings":"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","names":["FACEMESH_GRAPHMODEL_PATH","IRIS_GRAPHMODEL_PATH","MESH_MODEL_INPUT_WIDTH","MESH_MODEL_INPUT_HEIGHT","PREDICTION_VALUES","PREDICTION_TENSORS","load","config","_a","_b","detectionConfidence","_c","maxFaces","_d","iouThreshold","_e","scoreThreshold","_f","shouldLoadIrisModel","modelUrl","detectorModelUrl","irisModelUrl","Promise","all","loadDetectorModel","loadMeshModel","loadIrisModel","models","_g","faceMesh","FaceMesh","maxContinuousChecks","exports","blazeface","tfconv","loadGraphModel","fromTFHub","getInputTensorDimensions","input","tf","Tensor","shape","height","width","flipFaceHorizontal","face","imageWidth","mesh","topLeft","bottomRight","scaledMesh","Object","assign","boundingBox","map","flippedCoord","coord","slice","blazeFace","blazeMeshModel","irisModel","pipeline","pipeline_1","keypoints_1","uv_coords_1","flipHorizontal","predictIrises","Error","image","tidy","browser","fromPixels","expandDims","cast","getBackend","savedWebglPackDepthwiseConvFlag","env","get","set","predict","predictions","dispose","length","prediction","i","coords","scaledCoords","box","flag","tensorsToRead","returnTensors","concat","d","array","tensorValues","flagValue","clearRegionOfInterest","annotatedPrediction_1","kind","faceInViewConfidence","tensor1d","startPoint","endPoint","coordsArr","coordsArrScaled","annotatedPrediction","annotations","key","includes","index"],"sources":["../../src/mediapipe-facemesh/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}