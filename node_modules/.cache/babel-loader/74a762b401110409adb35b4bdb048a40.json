{"ast":null,"code":"import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\n\nfunction isService(actor) {\n  return 'state' in actor && 'machine' in actor;\n}\n\nvar defaultCompare = function (a, b) {\n  return a === b;\n};\n\nvar defaultGetSnapshot = function (a) {\n  return isService(a) ? getServiceSnapshot(a) : isActorWithState(a) ? a.state : undefined;\n};\n\nexport function useSelector(actor, selector, compare, getSnapshot) {\n  if (compare === void 0) {\n    compare = defaultCompare;\n  }\n\n  if (getSnapshot === void 0) {\n    getSnapshot = defaultGetSnapshot;\n  }\n\n  var latestSelectorRef = useRef(selector);\n  var subscription = useMemo(function () {\n    var snapshot = getSnapshot(actor);\n    var current = selector(snapshot);\n    var notifySubscriber;\n    return {\n      getSnapshot: function () {\n        return snapshot;\n      },\n      getCurrentValue: function () {\n        return current;\n      },\n      setCurrentValue: function (newCurrent) {\n        current = newCurrent;\n        notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n      },\n      subscribe: function (callback) {\n        notifySubscriber = callback;\n        var sub = actor.subscribe(function (emitted) {\n          snapshot = emitted;\n          var next = latestSelectorRef.current(emitted);\n\n          if (!compare(current, next)) {\n            current = next;\n            callback();\n          }\n        });\n        return function () {\n          sub.unsubscribe();\n        };\n      }\n    }; // intentionally omit `getSnapshot` and `compare`\n    // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n    // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n  }, [actor]);\n  var currentSelected = useSubscription(subscription);\n  var currentChanged = false;\n\n  if (latestSelectorRef.current !== selector) {\n    var selected = selector(subscription.getSnapshot());\n\n    if (!compare(currentSelected, selected)) {\n      currentChanged = true;\n      currentSelected = selected;\n    }\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelectorRef.current = selector; // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n\n    if (currentChanged) {\n      // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n      // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n      subscription.setCurrentValue(currentSelected);\n    }\n  });\n  return currentSelected;\n}","map":{"version":3,"sources":["/Users/angelinadeo/thehacktrical/NYUhack/node_modules/@xstate/react/es/useSelector.js"],"names":["useMemo","useRef","useSubscription","useIsomorphicLayoutEffect","isActorWithState","getServiceSnapshot","isService","actor","defaultCompare","a","b","defaultGetSnapshot","state","undefined","useSelector","selector","compare","getSnapshot","latestSelectorRef","subscription","snapshot","current","notifySubscriber","getCurrentValue","setCurrentValue","newCurrent","subscribe","callback","sub","emitted","next","unsubscribe","currentSelected","currentChanged","selected"],"mappings":"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","sourcesContent":["import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\nfunction isService(actor) {\n    return 'state' in actor && 'machine' in actor;\n}\nvar defaultCompare = function (a, b) { return a === b; };\nvar defaultGetSnapshot = function (a) {\n    return isService(a)\n        ? getServiceSnapshot(a)\n        : isActorWithState(a)\n            ? a.state\n            : undefined;\n};\nexport function useSelector(actor, selector, compare, getSnapshot) {\n    if (compare === void 0) { compare = defaultCompare; }\n    if (getSnapshot === void 0) { getSnapshot = defaultGetSnapshot; }\n    var latestSelectorRef = useRef(selector);\n    var subscription = useMemo(function () {\n        var snapshot = getSnapshot(actor);\n        var current = selector(snapshot);\n        var notifySubscriber;\n        return {\n            getSnapshot: function () { return snapshot; },\n            getCurrentValue: function () { return current; },\n            setCurrentValue: function (newCurrent) {\n                current = newCurrent;\n                notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n            },\n            subscribe: function (callback) {\n                notifySubscriber = callback;\n                var sub = actor.subscribe(function (emitted) {\n                    snapshot = emitted;\n                    var next = latestSelectorRef.current(emitted);\n                    if (!compare(current, next)) {\n                        current = next;\n                        callback();\n                    }\n                });\n                return function () {\n                    sub.unsubscribe();\n                };\n            }\n        };\n        // intentionally omit `getSnapshot` and `compare`\n        // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n        // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n    }, [actor]);\n    var currentSelected = useSubscription(subscription);\n    var currentChanged = false;\n    if (latestSelectorRef.current !== selector) {\n        var selected = selector(subscription.getSnapshot());\n        if (!compare(currentSelected, selected)) {\n            currentChanged = true;\n            currentSelected = selected;\n        }\n    }\n    useIsomorphicLayoutEffect(function () {\n        latestSelectorRef.current = selector;\n        // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n        if (currentChanged) {\n            // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n            // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n            subscription.setCurrentValue(currentSelected);\n        }\n    });\n    return currentSelected;\n}\n"]},"metadata":{},"sourceType":"module"}