{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _tslib = require('./_virtual/_tslib.js');\n\nvar utils = require('./utils.js');\n\nvar serviceScope = require('./serviceScope.js');\n\nfunction createNullActor(id) {\n  return _tslib.__assign({\n    id: id,\n    send: function () {\n      return void 0;\n    },\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    getSnapshot: function () {\n      return undefined;\n    },\n    toJSON: function () {\n      return {\n        id: id\n      };\n    }\n  }, utils.interopSymbols);\n}\n/**\r\n * Creates a deferred actor that is able to be invoked given the provided\r\n * invocation information in its `.meta` value.\r\n *\r\n * @param invokeDefinition The meta information needed to invoke the actor.\r\n */\n\n\nfunction createInvocableActor(invokeDefinition, machine, context, _event) {\n  var _a;\n\n  var invokeSrc = utils.toInvokeSource(invokeDefinition.src);\n  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];\n  var resolvedData = invokeDefinition.data ? utils.mapContext(invokeDefinition.data, context, _event) : undefined;\n  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore\n\n  tempActor.meta = invokeDefinition;\n  return tempActor;\n}\n\nfunction createDeferredActor(entity, id, data) {\n  var tempActor = createNullActor(id); // @ts-ignore\n\n  tempActor.deferred = true;\n\n  if (utils.isMachine(entity)) {\n    // \"mute\" the existing service scope so potential spawned actors within the `.initialState` stay deferred here\n    var initialState_1 = tempActor.state = serviceScope.provide(undefined, function () {\n      return (data ? entity.withContext(data) : entity).initialState;\n    });\n\n    tempActor.getSnapshot = function () {\n      return initialState_1;\n    };\n  }\n\n  return tempActor;\n}\n\nfunction isActor(item) {\n  try {\n    return typeof item.send === 'function';\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isSpawnedActor(item) {\n  return isActor(item) && 'id' in item;\n}\n\nfunction toActorRef(actorRefLike) {\n  return _tslib.__assign(_tslib.__assign({\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    id: 'anonymous',\n    getSnapshot: function () {\n      return undefined;\n    }\n  }, utils.interopSymbols), actorRefLike);\n}\n\nexports.createDeferredActor = createDeferredActor;\nexports.createInvocableActor = createInvocableActor;\nexports.createNullActor = createNullActor;\nexports.isActor = isActor;\nexports.isSpawnedActor = isSpawnedActor;\nexports.toActorRef = toActorRef;","map":{"version":3,"sources":["/Users/angelinadeo/thehacktrical/NYUhack/node_modules/xstate/lib/Actor.js"],"names":["Object","defineProperty","exports","value","_tslib","require","utils","serviceScope","createNullActor","id","__assign","send","subscribe","unsubscribe","getSnapshot","undefined","toJSON","interopSymbols","createInvocableActor","invokeDefinition","machine","context","_event","_a","invokeSrc","toInvokeSource","src","serviceCreator","options","services","type","resolvedData","data","mapContext","tempActor","createDeferredActor","meta","entity","deferred","isMachine","initialState_1","state","provide","withContext","initialState","isActor","item","e","isSpawnedActor","toActorRef","actorRefLike"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _tslib = require('./_virtual/_tslib.js');\nvar utils = require('./utils.js');\nvar serviceScope = require('./serviceScope.js');\n\nfunction createNullActor(id) {\n  return _tslib.__assign({\n    id: id,\n    send: function () {\n      return void 0;\n    },\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    getSnapshot: function () {\n      return undefined;\n    },\n    toJSON: function () {\n      return {\n        id: id\n      };\n    }\n  }, utils.interopSymbols);\n}\n/**\r\n * Creates a deferred actor that is able to be invoked given the provided\r\n * invocation information in its `.meta` value.\r\n *\r\n * @param invokeDefinition The meta information needed to invoke the actor.\r\n */\n\nfunction createInvocableActor(invokeDefinition, machine, context, _event) {\n  var _a;\n\n  var invokeSrc = utils.toInvokeSource(invokeDefinition.src);\n  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];\n  var resolvedData = invokeDefinition.data ? utils.mapContext(invokeDefinition.data, context, _event) : undefined;\n  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore\n\n  tempActor.meta = invokeDefinition;\n  return tempActor;\n}\nfunction createDeferredActor(entity, id, data) {\n  var tempActor = createNullActor(id); // @ts-ignore\n\n  tempActor.deferred = true;\n\n  if (utils.isMachine(entity)) {\n    // \"mute\" the existing service scope so potential spawned actors within the `.initialState` stay deferred here\n    var initialState_1 = tempActor.state = serviceScope.provide(undefined, function () {\n      return (data ? entity.withContext(data) : entity).initialState;\n    });\n\n    tempActor.getSnapshot = function () {\n      return initialState_1;\n    };\n  }\n\n  return tempActor;\n}\nfunction isActor(item) {\n  try {\n    return typeof item.send === 'function';\n  } catch (e) {\n    return false;\n  }\n}\nfunction isSpawnedActor(item) {\n  return isActor(item) && 'id' in item;\n}\nfunction toActorRef(actorRefLike) {\n  return _tslib.__assign(_tslib.__assign({\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    id: 'anonymous',\n    getSnapshot: function () {\n      return undefined;\n    }\n  }, utils.interopSymbols), actorRefLike);\n}\n\nexports.createDeferredActor = createDeferredActor;\nexports.createInvocableActor = createInvocableActor;\nexports.createNullActor = createNullActor;\nexports.isActor = isActor;\nexports.isSpawnedActor = isSpawnedActor;\nexports.toActorRef = toActorRef;\n"]},"metadata":{},"sourceType":"script"}