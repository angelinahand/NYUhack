{"ast":null,"code":"import { useEscapeKeydown as e } from \"@radix-ui/react-use-escape-keydown\";\nimport { useCallbackRef as t } from \"@radix-ui/react-use-callback-ref\";\nimport { useBodyPointerEvents as n } from \"@radix-ui/react-use-body-pointer-events\";\nimport { createContext as r } from \"@radix-ui/react-context\";\nimport { Primitive as o } from \"@radix-ui/react-primitive\";\nimport { composeEventHandlers as u } from \"@radix-ui/primitive\";\nimport * as i from \"react\";\nimport s from \"@babel/runtime/helpers/esm/extends\";\nconst [a, c] = C(),\n      [l, d] = b(),\n      [m, f] = C(\"TotalLayerCountWithDisabledOutsidePointerEventsProvider\"),\n      [p, v] = b(\"RunningLayerCountWithDisabledOutsidePointerEventsProvider\");\nexport const DismissableLayer = /*#__PURE__*/i.forwardRef((e, t) => {\n  const n = 0 === d(),\n        r = /*#__PURE__*/i.createElement(E, s({}, e, {\n    ref: t\n  }));\n  return n ? /*#__PURE__*/i.createElement(a, null, /*#__PURE__*/i.createElement(m, null, r)) : r;\n});\n/*#__PURE__*/\n\nconst E = /*#__PURE__*/i.forwardRef((r, a) => {\n  const {\n    disableOutsidePointerEvents: m = !1,\n    onEscapeKeyDown: E,\n    onPointerDownOutside: C,\n    onFocusOutside: b,\n    onInteractOutside: w,\n    onDismiss: L,\n    ...y\n  } = r,\n        D = c(),\n        P = d() + 1,\n        T = P === D,\n        g = f(m),\n        x = v() + (m ? 1 : 0),\n        O = x < g;\n  n({\n    disabled: m\n  }), e(e => {\n    T && (null == E || E(e), e.defaultPrevented || null == L || L());\n  });\n\n  const {\n    onPointerDownCapture: R\n  } = function (e) {\n    const n = t(e),\n          r = i.useRef(!1);\n    return i.useEffect(() => {\n      const e = e => {\n        const t = e.target;\n\n        if (t && !r.current) {\n          const r = new CustomEvent(\"dismissableLayer.pointerDownOutside\", {\n            bubbles: !1,\n            cancelable: !0,\n            detail: {\n              originalEvent: e\n            }\n          });\n          t.addEventListener(\"dismissableLayer.pointerDownOutside\", n, {\n            once: !0\n          }), t.dispatchEvent(r);\n        }\n\n        r.current = !1;\n      },\n            t = window.setTimeout(() => {\n        document.addEventListener(\"pointerdown\", e);\n      }, 0);\n\n      return () => {\n        window.clearTimeout(t), document.removeEventListener(\"pointerdown\", e);\n      };\n    }, [n]), {\n      onPointerDownCapture: () => r.current = !0\n    };\n  }(e => {\n    O || (null == C || C(e), null == w || w(e), e.defaultPrevented || null == L || L());\n  }),\n        {\n    onBlurCapture: h,\n    onFocusCapture: F\n  } = function (e) {\n    const n = t(e),\n          r = i.useRef(!1);\n    return i.useEffect(() => {\n      const e = e => {\n        const t = e.target;\n\n        if (t && !r.current) {\n          const r = new CustomEvent(\"dismissableLayer.focusOutside\", {\n            bubbles: !1,\n            cancelable: !0,\n            detail: {\n              originalEvent: e\n            }\n          });\n          t.addEventListener(\"dismissableLayer.focusOutside\", n, {\n            once: !0\n          }), t.dispatchEvent(r);\n        }\n      };\n\n      return document.addEventListener(\"focusin\", e), () => document.removeEventListener(\"focusin\", e);\n    }, [n]), {\n      onFocusCapture: () => r.current = !0,\n      onBlurCapture: () => r.current = !1\n    };\n  }(e => {\n    null == b || b(e), null == w || w(e), e.defaultPrevented || null == L || L();\n  }),\n        k = g > 0 && !O;\n  /*#__PURE__*/\n\n\n  return i.createElement(l, {\n    runningCount: P\n  }, /*#__PURE__*/i.createElement(p, {\n    runningCount: x\n  }, /*#__PURE__*/i.createElement(o.div, s({}, y, {\n    ref: a,\n    style: {\n      pointerEvents: k ? \"auto\" : void 0,\n      ...y.style\n    },\n    onPointerDownCapture: u(r.onPointerDownCapture, R),\n    onBlurCapture: u(r.onBlurCapture, h),\n    onFocusCapture: u(r.onFocusCapture, F)\n  }))));\n});\n\nfunction C(e) {\n  const [t, n] = r(\"TotalLayerCount\", {\n    total: 0,\n    onTotalIncrease: () => {},\n    onTotalDecrease: () => {}\n  }),\n        o = _ref => {\n    let {\n      children: e\n    } = _ref;\n    const [n, r] = i.useState(0);\n    /*#__PURE__*/\n\n    return i.createElement(t, {\n      total: n,\n      onTotalIncrease: i.useCallback(() => r(e => e + 1), []),\n      onTotalDecrease: i.useCallback(() => r(e => e - 1), [])\n    }, e);\n  };\n\n  return [o, function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n    const {\n      total: t,\n      onTotalIncrease: r,\n      onTotalDecrease: o\n    } = n(\"TotalLayerCountConsumer\");\n    return i.useLayoutEffect(() => {\n      if (e) return r(), () => o();\n    }, [e, r, o]), t;\n  }];\n}\n\nfunction b(e) {\n  const [t, n] = r(\"RunningLayerCount\", {\n    count: 0\n  }),\n        o = e => {\n    const {\n      children: n,\n      runningCount: r\n    } = e;\n    /*#__PURE__*/\n\n    return i.createElement(t, {\n      count: r\n    }, n);\n  };\n\n  return [o, function () {\n    return n(\"RunningLayerCountConsumer\").count || 0;\n  }];\n}\n\nexport const Root = DismissableLayer;","map":{"version":3,"mappings":"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","names":["TotalLayerCountProvider","useTotalLayerCount","createTotalLayerCount","RunningLayerCountProvider","usePreviousRunningLayerCount","createRunningLayerCount","TotalLayerCountWithDisabledOutsidePointerEventsProvider","useTotalLayerCountWithDisabledOutsidePointerEvents","RunningLayerCountWithDisabledOutsidePointerEventsProvider","usePreviousRunningLayerCountWithDisabledOutsidePointerEvents","DismissableLayer","React","forwardRef","props","forwardedRef","isRootLayer","layer","_react","$b3ca5e0c42ec5d7395c8cb24157$var$DismissableLayerImpl","_babelRuntimeHelpersEsmExtends","ref","$b3ca5e0c42ec5d7395c8cb24157$var$TotalLayerCountProvider","$b3ca5e0c42ec5d7395c8cb24157$var$TotalLayerCountWithDisabledOutsidePointerEventsProvider","DismissableLayerImpl","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss","layerProps","totalLayerCount","runningLayerCount","isDeepestLayer","totalLayerCountWithDisabledOutsidePointerEvents","runningLayerCountWithDisabledOutsidePointerEvents","containsChildLayerWithDisabledOutsidePointerEvents","useBodyPointerEvents","disabled","useEscapeKeydown","event","defaultPrevented","onPointerDownCapture","handlePointerDownCapture","handlePointerDownOutside","useCallbackRef","isPointerInsideReactTreeRef","useRef","useEffect","handlePointerDown","target","current","pointerDownOutsideEvent","CustomEvent","bubbles","cancelable","detail","originalEvent","addEventListener","once","dispatchEvent","timerId","window","setTimeout","document","clearTimeout","removeEventListener","usePointerDownOutside","onBlurCapture","handleBlurCapture","onFocusCapture","handleFocusCapture","handleFocusOutside","isFocusInsideReactTreeRef","handleFocus","focusOutsideEvent","useFocusOutside","shouldReEnablePointerEvents","$b3ca5e0c42ec5d7395c8cb24157$var$RunningLayerCountProvider","runningCount","$b3ca5e0c42ec5d7395c8cb24157$var$RunningLayerCountWithDisabledOutsidePointerEventsProvider","Primitive","div","style","pointerEvents","undefined","composeEventHandlers","displayName","TotalLayerCountProviderImpl","useTotalLayerCountContext","createContext","total","onTotalIncrease","onTotalDecrease","children","setTotal","useState","useCallback","n","counted","useLayoutEffect","RunningLayerCountProviderImp","useRunningLayerCount","count","Root"],"sources":["/Users/angelinadeo/thehacktrical/NYUhack/node_modules/@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createContext } from '@radix-ui/react-context';\nimport { useBodyPointerEvents } from '@radix-ui/react-use-body-pointer-events';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n// We need to compute the total count of layers AND a running count of all layers\n// in order to find which layer is the deepest one.\n// This is use to only dismiss the deepest layer when using the escape key\n// because we bind the key listener to document so cannot take advantage of event.stopPropagation()\nconst [TotalLayerCountProvider, useTotalLayerCount] = createTotalLayerCount();\nconst [RunningLayerCountProvider, usePreviousRunningLayerCount] = createRunningLayerCount();\n\n// We need to compute the total count of layers which set `disableOutsidePointerEvents` to `true` AND\n// a running count of all the layers which set `disableOutsidePointerEvents` to `true` in order to determine\n// which layers should be dismissed when interacting outside.\n// (ie. all layers that do not have a child layer which sets `disableOutsidePointerEvents` to `true`)\nconst [\n  TotalLayerCountWithDisabledOutsidePointerEventsProvider,\n  useTotalLayerCountWithDisabledOutsidePointerEvents,\n] = createTotalLayerCount('TotalLayerCountWithDisabledOutsidePointerEventsProvider');\nconst [\n  RunningLayerCountWithDisabledOutsidePointerEventsProvider,\n  usePreviousRunningLayerCountWithDisabledOutsidePointerEvents,\n] = createRunningLayerCount('RunningLayerCountWithDisabledOutsidePointerEventsProvider');\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\n\ntype DismissableLayerElement = DismissableLayerImplElement;\ninterface DismissableLayerProps extends DismissableLayerImplProps {}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const runningLayerCount = usePreviousRunningLayerCount();\n    const isRootLayer = runningLayerCount === 0;\n    const layer = <DismissableLayerImpl {...props} ref={forwardedRef} />;\n\n    // if it's the root layer, we wrap it with our necessary root providers\n    // (effectively we wrap the whole tree of nested layers)\n    return isRootLayer ? (\n      <TotalLayerCountProvider>\n        <TotalLayerCountWithDisabledOutsidePointerEventsProvider>\n          {layer}\n        </TotalLayerCountWithDisabledOutsidePointerEventsProvider>\n      </TotalLayerCountProvider>\n    ) : (\n      layer\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DismissableLayerImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerImplProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n\n  /** Callback called when the `DismissableLayer` should be dismissed */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayerImpl = React.forwardRef<\n  DismissableLayerImplElement,\n  DismissableLayerImplProps\n>((props, forwardedRef) => {\n  const {\n    disableOutsidePointerEvents = false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    ...layerProps\n  } = props;\n\n  const totalLayerCount = useTotalLayerCount();\n  const prevRunningLayerCount = usePreviousRunningLayerCount();\n  const runningLayerCount = prevRunningLayerCount + 1;\n  const isDeepestLayer = runningLayerCount === totalLayerCount;\n\n  const totalLayerCountWithDisabledOutsidePointerEvents =\n    useTotalLayerCountWithDisabledOutsidePointerEvents(disableOutsidePointerEvents);\n  const prevRunningLayerCountWithDisabledOutsidePointerEvents =\n    usePreviousRunningLayerCountWithDisabledOutsidePointerEvents();\n  const runningLayerCountWithDisabledOutsidePointerEvents =\n    prevRunningLayerCountWithDisabledOutsidePointerEvents + (disableOutsidePointerEvents ? 1 : 0);\n  const containsChildLayerWithDisabledOutsidePointerEvents =\n    runningLayerCountWithDisabledOutsidePointerEvents <\n    totalLayerCountWithDisabledOutsidePointerEvents;\n\n  // Disable pointer-events on `document.body` when at least one layer is disabling outside pointer events\n  useBodyPointerEvents({ disabled: disableOutsidePointerEvents });\n\n  // Dismiss on escape\n  useEscapeKeydown((event) => {\n    // Only dismiss if it's the deepest layer. his is effectively mimicking\n    // event.stopPropagation from the layer with disabled outside pointer events.\n    if (isDeepestLayer) {\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  });\n\n  // Dismiss on pointer down outside\n  const { onPointerDownCapture: handlePointerDownCapture } = usePointerDownOutside((event) => {\n    // Only dismiss if there's no deeper layer which disabled pointer events outside itself\n    if (!containsChildLayerWithDisabledOutsidePointerEvents) {\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  });\n\n  // Dismiss on focus outside\n  const { onBlurCapture: handleBlurCapture, onFocusCapture: handleFocusCapture } = useFocusOutside(\n    (event) => {\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  );\n\n  // If we have disabled pointer events on body, we need to reset `pointerEvents: 'auto'`\n  // on some layers. This depends on which layers set `disableOutsidePointerEvents` to `true`.\n  //\n  // NOTE: it's important we set it on ALL layers that need it as we cannot simply\n  // set it on the deepest layer which sets `disableOutsidePointerEvents` to `true` and rely\n  // on inheritence. This is because layers may be rendered in different portals where\n  // inheritence wouldn't apply, so we need to set it explicity on its children too.\n  const isBodyPointerEventsDisabled = totalLayerCountWithDisabledOutsidePointerEvents > 0;\n  const shouldReEnablePointerEvents =\n    isBodyPointerEventsDisabled && !containsChildLayerWithDisabledOutsidePointerEvents;\n\n  return (\n    <RunningLayerCountProvider runningCount={runningLayerCount}>\n      <RunningLayerCountWithDisabledOutsidePointerEventsProvider\n        runningCount={runningLayerCountWithDisabledOutsidePointerEvents}\n      >\n        <Primitive.div\n          {...layerProps}\n          ref={forwardedRef}\n          style={{\n            pointerEvents: shouldReEnablePointerEvents ? 'auto' : undefined,\n            ...layerProps.style,\n          }}\n          onPointerDownCapture={composeEventHandlers(\n            props.onPointerDownCapture,\n            handlePointerDownCapture\n          )}\n          onBlurCapture={composeEventHandlers(props.onBlurCapture, handleBlurCapture)}\n          onFocusCapture={composeEventHandlers(props.onFocusCapture, handleFocusCapture)}\n        />\n      </RunningLayerCountWithDisabledOutsidePointerEventsProvider>\n    </RunningLayerCountProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * Utility hooks\n * -----------------------------------------------------------------------------------------------*/\n\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Sets up `pointerdown` listener which listens for events outside a react subtree.\n *\n * We use `pointerdown` rather than `pointerup` to mimic layer dismissing behaviour\n * present in OS which usually happens on `pointerdown`.\n *\n * Returns props to pass to the node we want to check for outside events.\n */\n\nfunction usePointerDownOutside(onPointerDownOutside?: (event: PointerDownOutsideEvent) => void) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      const target = event.target;\n      if (target && !isPointerInsideReactTreeRef.current) {\n        const pointerDownOutsideEvent: PointerDownOutsideEvent = new CustomEvent(\n          POINTER_DOWN_OUTSIDE,\n          { bubbles: false, cancelable: true, detail: { originalEvent: event } }\n        );\n        target.addEventListener(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, { once: true });\n        target.dispatchEvent(pointerDownOutsideEvent);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n    };\n  }, [handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\n\nfunction useFocusOutside(onFocusOutside?: (event: FocusOutsideEvent) => void) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      const target = event.target;\n      if (target && !isFocusInsideReactTreeRef.current) {\n        const focusOutsideEvent: FocusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE, {\n          bubbles: false,\n          cancelable: true,\n          detail: { originalEvent: event },\n        });\n        target.addEventListener(FOCUS_OUTSIDE, handleFocusOutside, { once: true });\n        target.dispatchEvent(focusOutsideEvent);\n      }\n    };\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Layer counting utilities\n * -----------------------------------------------------------------------------------------------*/\n\nfunction createTotalLayerCount(displayName?: string) {\n  const [TotalLayerCountProviderImpl, useTotalLayerCountContext] = createContext(\n    'TotalLayerCount',\n    { total: 0, onTotalIncrease: () => {}, onTotalDecrease: () => {} }\n  );\n\n  const TotalLayerCountProvider: React.FC = ({ children }) => {\n    const [total, setTotal] = React.useState(0);\n    return (\n      <TotalLayerCountProviderImpl\n        total={total}\n        onTotalIncrease={React.useCallback(() => setTotal((n) => n + 1), [])}\n        onTotalDecrease={React.useCallback(() => setTotal((n) => n - 1), [])}\n      >\n        {children}\n      </TotalLayerCountProviderImpl>\n    );\n  };\n  if (displayName) {\n    TotalLayerCountProvider.displayName = displayName;\n  }\n\n  function useTotalLayerCount(counted = true) {\n    const { total, onTotalIncrease, onTotalDecrease } =\n      useTotalLayerCountContext('TotalLayerCountConsumer');\n\n    React.useLayoutEffect(() => {\n      if (counted) {\n        onTotalIncrease();\n        return () => onTotalDecrease();\n      }\n    }, [counted, onTotalIncrease, onTotalDecrease]);\n\n    return total;\n  }\n\n  return [TotalLayerCountProvider, useTotalLayerCount] as const;\n}\n\nfunction createRunningLayerCount(displayName?: string) {\n  const [RunningLayerCountProviderImp, useRunningLayerCount] = createContext('RunningLayerCount', {\n    count: 0,\n  });\n\n  const RunningLayerCountProvider: React.FC<{ runningCount: number }> = (props) => {\n    const { children, runningCount } = props;\n    return (\n      <RunningLayerCountProviderImp count={runningCount}>{children}</RunningLayerCountProviderImp>\n    );\n  };\n  if (displayName) {\n    RunningLayerCountProvider.displayName = displayName;\n  }\n\n  function usePreviousRunningLayerCount() {\n    const context = useRunningLayerCount('RunningLayerCountConsumer');\n    return context.count || 0;\n  }\n\n  return [RunningLayerCountProvider, usePreviousRunningLayerCount] as const;\n}\n\nconst Root = DismissableLayer;\n\nexport {\n  DismissableLayer,\n  //\n  Root,\n};\nexport type { DismissableLayerProps };\n"]},"metadata":{},"sourceType":"module"}