{"ast":null,"code":"var _jsxFileName = \"/Users/angelinadeo/thehacktrical/NYUhack/src/util/demo.js\",\n    _s = $RefreshSig$();\n\nimport \"@tensorflow/tfjs-core\";\nimport \"@tensorflow/tfjs-converter\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { draw } from \"./mask\";\nimport { getDistance, getAngle, overallXAngle, overallYAngle, averageAngles } from \"./analyzePoints\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Demo = props => {\n  _s();\n\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [frames, setFrames] = useState(0);\n  const [tog, setTog] = useState(false);\n  const [first, setFirst] = useState(true);\n  const [done, setDone] = useState(false);\n  const [loaded, setLoaded] = useState(false);\n  const [model, setModel] = useState(null);\n  const [dist, setDist] = useState(0);\n  const [xAngle, setXAngle] = useState(0);\n  const [yAngle, setYAngle] = useState(0);\n  const [overallAngle, setOverallAngle] = useState(0);\n  const [angleMeasures, setAngleMeasures] = useState([]);\n  const [focused, setFocused] = useState(true);\n  const loop = true;\n  const consoleOuput = false;\n\n  const runPredict = async () => {\n    if (consoleOuput) {\n      console.log(\"loading model\");\n    }\n\n    setModel(await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh));\n    setLoaded(true);\n    detect(model);\n  };\n\n  const detect = async model => {\n    const t0 = new Date().getTime();\n\n    if (videoRef.current) {\n      const webcamCurrent = videoRef.current;\n      const videoWidth = webcamCurrent.video.videoWidth;\n      const videoHeight = webcamCurrent.video.videoHeight; // go next step only when the video is completely uploaded.\n\n      if (webcamCurrent.video.readyState === 4) {\n        if (first) {\n          setFirst(false);\n          canvasRef.current.width = videoWidth;\n          canvasRef.current.height = videoHeight;\n        }\n\n        const video = webcamCurrent.video;\n        const predictions = await model.estimateFaces({\n          input: video\n        });\n\n        if (predictions.length) {\n          if (consoleOuput) {\n            console.log(predictions);\n          }\n\n          if (!loop) {\n            setDone(true);\n          }\n\n          const ctx = canvasRef.current.getContext(\"2d\");\n          requestAnimationFrame(() => {\n            if (consoleOuput) {\n              console.log(\"drawing\");\n            }\n\n            draw(predictions, ctx, videoWidth, videoHeight);\n            setDist(getDistance(predictions));\n            const {\n              xAngle,\n              yAngle\n            } = getAngle(predictions);\n            setXAngle(xAngle);\n            setYAngle(yAngle);\n            setAngleMeasures(prev => {\n              const msrs = [...prev];\n\n              if (msrs.length >= 10) {\n                msrs.splice(0, 1);\n              }\n\n              msrs.push({\n                x: overallXAngle(predictions),\n                y: overallYAngle(predictions)\n              });\n              setOverallAngle(averageAngles(msrs));\n              return msrs;\n            });\n            setFocused(isFocused());\n          });\n          const t1 = new Date().getTime();\n          setFrames(1 / ((t1 - t0) / 1000)); //detect(model)\n        }\n      }\n    }\n\n    setTog(!tog);\n  };\n\n  useEffect(() => {\n    if (!done) {\n      if (model === null) {\n        runPredict();\n      } else {\n        detect(model);\n      }\n    }\n  }, [videoRef, tog]);\n  useEffect(() => {\n    props.focusChange(focused);\n  }, [focused]);\n\n  const isFocused = () => {\n    console.log(overallAngle.y);\n    return Math.abs(overallAngle.x) < 25 && Math.abs(overallAngle.y) < 30;\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: \"absolute\",\n      background: \"transparent\",\n      top: 0,\n      left: 0\n    },\n    children: [/*#__PURE__*/_jsxDEV(Webcam, {\n      id: \"video\",\n      ref: videoRef,\n      style: {\n        opacity: 0,\n        position: \"absolute\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"fixed\",\n        top: (overallAngle.y - 20) / -40 * window.innerHeight,\n        left: (overallAngle.x - 20) / -40 * window.innerWidth,\n        height: 100,\n        width: 100,\n        borderRadius: 50,\n        backgroundColor: \"rgba(207, 207, 196, 0.2)\",\n        zIndex: 1\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 125,\n    columnNumber: 5\n  }, this);\n};\n\n_s(Demo, \"eOVhCXP2YFtYy7qr90EWhtiXr50=\");\n\n_c = Demo;\nexport default Demo;\n\nvar _c;\n\n$RefreshReg$(_c, \"Demo\");","map":{"version":3,"sources":["/Users/angelinadeo/thehacktrical/NYUhack/src/util/demo.js"],"names":["faceLandmarksDetection","React","useEffect","useRef","useState","Webcam","draw","getDistance","getAngle","overallXAngle","overallYAngle","averageAngles","Demo","props","videoRef","canvasRef","frames","setFrames","tog","setTog","first","setFirst","done","setDone","loaded","setLoaded","model","setModel","dist","setDist","xAngle","setXAngle","yAngle","setYAngle","overallAngle","setOverallAngle","angleMeasures","setAngleMeasures","focused","setFocused","loop","consoleOuput","runPredict","console","log","load","SupportedPackages","mediapipeFacemesh","detect","t0","Date","getTime","current","webcamCurrent","videoWidth","video","videoHeight","readyState","width","height","predictions","estimateFaces","input","length","ctx","getContext","requestAnimationFrame","prev","msrs","splice","push","x","y","isFocused","t1","focusChange","Math","abs","position","background","top","left","opacity","window","innerHeight","innerWidth","borderRadius","backgroundColor","zIndex"],"mappings":"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","sourcesContent":["import \"@tensorflow/tfjs-core\";\nimport \"@tensorflow/tfjs-converter\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { draw } from \"./mask\";\nimport {\n  getDistance,\n  getAngle,\n  overallXAngle,\n  overallYAngle,\n  averageAngles,\n} from \"./analyzePoints\";\n\nconst Demo = (props) => {\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [frames, setFrames] = useState(0);\n  const [tog, setTog] = useState(false);\n  const [first, setFirst] = useState(true);\n  const [done, setDone] = useState(false);\n  const [loaded, setLoaded] = useState(false);\n  const [model, setModel] = useState(null);\n\n  const [dist, setDist] = useState(0);\n  const [xAngle, setXAngle] = useState(0);\n  const [yAngle, setYAngle] = useState(0);\n  const [overallAngle, setOverallAngle] = useState(0);\n  const [angleMeasures, setAngleMeasures] = useState([]);\n  const [focused, setFocused] = useState(true);\n\n  const loop = true;\n  const consoleOuput = false;\n\n  const runPredict = async () => {\n    if (consoleOuput) {\n      console.log(\"loading model\");\n    }\n    setModel(\n      await faceLandmarksDetection.load(\n        faceLandmarksDetection.SupportedPackages.mediapipeFacemesh\n      )\n    );\n    setLoaded(true);\n    detect(model);\n  };\n  const detect = async (model) => {\n    const t0 = new Date().getTime();\n    if (videoRef.current) {\n      const webcamCurrent = videoRef.current;\n      const videoWidth = webcamCurrent.video.videoWidth;\n      const videoHeight = webcamCurrent.video.videoHeight;\n      // go next step only when the video is completely uploaded.\n      if (webcamCurrent.video.readyState === 4) {\n        if (first) {\n          setFirst(false);\n          canvasRef.current.width = videoWidth;\n          canvasRef.current.height = videoHeight;\n        }\n        const video = webcamCurrent.video;\n        const predictions = await model.estimateFaces({\n          input: video,\n        });\n        if (predictions.length) {\n          if (consoleOuput) {\n            console.log(predictions);\n          }\n          if (!loop) {\n            setDone(true);\n          }\n          const ctx = canvasRef.current.getContext(\"2d\");\n          requestAnimationFrame(() => {\n            if (consoleOuput) {\n              console.log(\"drawing\");\n            }\n            draw(predictions, ctx, videoWidth, videoHeight);\n            setDist(getDistance(predictions));\n            const { xAngle, yAngle } = getAngle(predictions);\n            setXAngle(xAngle);\n            setYAngle(yAngle);\n            setAngleMeasures((prev) => {\n              const msrs = [...prev];\n              if (msrs.length >= 10) {\n                msrs.splice(0, 1);\n              }\n              msrs.push({\n                x: overallXAngle(predictions),\n                y: overallYAngle(predictions),\n              });\n              setOverallAngle(averageAngles(msrs));\n              return msrs;\n            });\n            setFocused(isFocused());\n          });\n\n          const t1 = new Date().getTime();\n          setFrames(1 / ((t1 - t0) / 1000));\n          //detect(model)\n        }\n      }\n    }\n    setTog(!tog);\n  };\n  useEffect(() => {\n    if (!done) {\n      if (model === null) {\n        runPredict();\n      } else {\n        detect(model);\n      }\n    }\n  }, [videoRef, tog]);\n\n  useEffect(() => {\n    props.focusChange(focused);\n  }, [focused]);\n\n  const isFocused = () => {\n    console.log(overallAngle.y);\n    return Math.abs(overallAngle.x) < 25 && Math.abs(overallAngle.y) < 30;\n  };\n\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        background: \"transparent\",\n        top: 0,\n        left: 0,\n      }} \n    >\n      <Webcam\n        id=\"video\"\n        ref={videoRef}\n        style={{ opacity: 0, position: \"absolute\" }}\n      ></Webcam>\n      <canvas ref={canvasRef} />\n      <div\n        style={{\n          position: \"fixed\",\n          top: ((overallAngle.y - 20) / -40) * window.innerHeight,\n          left: ((overallAngle.x - 20) / -40) * window.innerWidth,\n          height: 100,\n          width: 100,\n          borderRadius: 50,\n          backgroundColor: \"rgba(207, 207, 196, 0.2)\",\n          zIndex: 1,\n        }}\n      />\n    </div>\n  );\n};\n\nexport default Demo;\n"]},"metadata":{},"sourceType":"module"}