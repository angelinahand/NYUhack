{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs-core\");\n\nvar box_1 = require(\"./box\");\n\nvar keypoints_1 = require(\"./keypoints\");\n\nvar util_1 = require(\"./util\");\n\nvar LANDMARKS_COUNT = 468;\nvar UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD = 0.25;\nvar MESH_MOUTH_INDEX = 13;\nvar MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES = [MESH_MOUTH_INDEX, keypoints_1.MESH_ANNOTATIONS['midwayBetweenEyes'][0]];\nvar BLAZEFACE_MOUTH_INDEX = 3;\nvar BLAZEFACE_NOSE_INDEX = 2;\nvar BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES = [BLAZEFACE_MOUTH_INDEX, BLAZEFACE_NOSE_INDEX];\nvar LEFT_EYE_OUTLINE = keypoints_1.MESH_ANNOTATIONS['leftEyeLower0'];\nvar LEFT_EYE_BOUNDS = [LEFT_EYE_OUTLINE[0], LEFT_EYE_OUTLINE[LEFT_EYE_OUTLINE.length - 1]];\nvar RIGHT_EYE_OUTLINE = keypoints_1.MESH_ANNOTATIONS['rightEyeLower0'];\nvar RIGHT_EYE_BOUNDS = [RIGHT_EYE_OUTLINE[0], RIGHT_EYE_OUTLINE[RIGHT_EYE_OUTLINE.length - 1]];\nvar IRIS_UPPER_CENTER_INDEX = 3;\nvar IRIS_LOWER_CENTER_INDEX = 4;\nvar IRIS_IRIS_INDEX = 71;\nvar IRIS_NUM_COORDINATES = 76; // Factor by which to enlarge the box around the eye landmarks so the input\n// region matches the expectations of the iris model.\n\nvar ENLARGE_EYE_RATIO = 2.3;\nvar IRIS_MODEL_INPUT_SIZE = 64; // A mapping from facemesh model keypoints to iris model keypoints.\n\nvar MESH_TO_IRIS_INDICES_MAP = [{\n  key: 'EyeUpper0',\n  indices: [9, 10, 11, 12, 13, 14, 15]\n}, {\n  key: 'EyeUpper1',\n  indices: [25, 26, 27, 28, 29, 30, 31]\n}, {\n  key: 'EyeUpper2',\n  indices: [41, 42, 43, 44, 45, 46, 47]\n}, {\n  key: 'EyeLower0',\n  indices: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n}, {\n  key: 'EyeLower1',\n  indices: [16, 17, 18, 19, 20, 21, 22, 23, 24]\n}, {\n  key: 'EyeLower2',\n  indices: [32, 33, 34, 35, 36, 37, 38, 39, 40]\n}, {\n  key: 'EyeLower3',\n  indices: [54, 55, 56, 57, 58, 59, 60, 61, 62]\n}, {\n  key: 'EyebrowUpper',\n  indices: [63, 64, 65, 66, 67, 68, 69, 70]\n}, {\n  key: 'EyebrowLower',\n  indices: [48, 49, 50, 51, 52, 53]\n}]; // Replace the raw coordinates returned by facemesh with refined iris model\n// coordinates.\n// Update the z coordinate to be an average of the original and the new. This\n// produces the best visual effect.\n\nfunction replaceRawCoordinates(rawCoords, newCoords, prefix, keys) {\n  for (var i = 0; i < MESH_TO_IRIS_INDICES_MAP.length; i++) {\n    var _a = MESH_TO_IRIS_INDICES_MAP[i],\n        key = _a.key,\n        indices = _a.indices;\n    var originalIndices = keypoints_1.MESH_ANNOTATIONS[\"\" + prefix + key];\n    var shouldReplaceAllKeys = keys == null;\n\n    if (shouldReplaceAllKeys || keys.includes(key)) {\n      for (var j = 0; j < indices.length; j++) {\n        var index = indices[j];\n        rawCoords[originalIndices[j]] = [newCoords[index][0], newCoords[index][1], (newCoords[index][2] + rawCoords[originalIndices[j]][2]) / 2];\n      }\n    }\n  }\n} // The Pipeline coordinates between the bounding box and skeleton models.\n\n\nvar Pipeline =\n/** @class */\nfunction () {\n  function Pipeline(boundingBoxDetector, meshDetector, meshWidth, meshHeight, maxContinuousChecks, maxFaces, irisModel) {\n    // An array of facial bounding boxes.\n    this.regionsOfInterest = [];\n    this.runsWithoutFaceDetector = 0;\n    this.boundingBoxDetector = boundingBoxDetector;\n    this.meshDetector = meshDetector;\n    this.irisModel = irisModel;\n    this.meshWidth = meshWidth;\n    this.meshHeight = meshHeight;\n    this.maxContinuousChecks = maxContinuousChecks;\n    this.maxFaces = maxFaces;\n  }\n\n  Pipeline.prototype.transformRawCoords = function (rawCoords, box, angle, rotationMatrix) {\n    var _this = this;\n\n    var boxSize = box_1.getBoxSize({\n      startPoint: box.startPoint,\n      endPoint: box.endPoint\n    });\n    var scaleFactor = [boxSize[0] / this.meshWidth, boxSize[1] / this.meshHeight];\n    var coordsScaled = rawCoords.map(function (coord) {\n      return [scaleFactor[0] * (coord[0] - _this.meshWidth / 2), scaleFactor[1] * (coord[1] - _this.meshHeight / 2), coord[2]];\n    });\n    var coordsRotationMatrix = util_1.buildRotationMatrix(angle, [0, 0]);\n    var coordsRotated = coordsScaled.map(function (coord) {\n      return util_1.rotatePoint(coord, coordsRotationMatrix).concat([coord[2]]);\n    });\n    var inverseRotationMatrix = util_1.invertTransformMatrix(rotationMatrix);\n    var boxCenter = box_1.getBoxCenter({\n      startPoint: box.startPoint,\n      endPoint: box.endPoint\n    }).concat([1]);\n    var originalBoxCenter = [util_1.dot(boxCenter, inverseRotationMatrix[0]), util_1.dot(boxCenter, inverseRotationMatrix[1])];\n    return coordsRotated.map(function (coord) {\n      return [coord[0] + originalBoxCenter[0], coord[1] + originalBoxCenter[1], coord[2]];\n    });\n  };\n\n  Pipeline.prototype.getLeftToRightEyeDepthDifference = function (rawCoords) {\n    var leftEyeZ = rawCoords[LEFT_EYE_BOUNDS[0]][2];\n    var rightEyeZ = rawCoords[RIGHT_EYE_BOUNDS[0]][2];\n    return leftEyeZ - rightEyeZ;\n  }; // Returns a box describing a cropped region around the eye fit for passing to\n  // the iris model.\n\n\n  Pipeline.prototype.getEyeBox = function (rawCoords, face, eyeInnerCornerIndex, eyeOuterCornerIndex, flip) {\n    if (flip === void 0) {\n      flip = false;\n    }\n\n    var box = box_1.squarifyBox(box_1.enlargeBox(this.calculateLandmarksBoundingBox([rawCoords[eyeInnerCornerIndex], rawCoords[eyeOuterCornerIndex]]), ENLARGE_EYE_RATIO));\n    var boxSize = box_1.getBoxSize(box);\n    var crop = tf.image.cropAndResize(face, [[box.startPoint[1] / this.meshHeight, box.startPoint[0] / this.meshWidth, box.endPoint[1] / this.meshHeight, box.endPoint[0] / this.meshWidth]], [0], [IRIS_MODEL_INPUT_SIZE, IRIS_MODEL_INPUT_SIZE]);\n\n    if (flip) {\n      crop = tf.image.flipLeftRight(crop);\n    }\n\n    return {\n      box: box,\n      boxSize: boxSize,\n      crop: crop\n    };\n  }; // Given a cropped image of an eye, returns the coordinates of the contours\n  // surrounding the eye and the iris.\n\n\n  Pipeline.prototype.getEyeCoords = function (eyeData, eyeBox, eyeBoxSize, flip) {\n    if (flip === void 0) {\n      flip = false;\n    }\n\n    var eyeRawCoords = [];\n\n    for (var i = 0; i < IRIS_NUM_COORDINATES; i++) {\n      var x = eyeData[i * 3];\n      var y = eyeData[i * 3 + 1];\n      var z = eyeData[i * 3 + 2];\n      eyeRawCoords.push([(flip ? 1 - x / IRIS_MODEL_INPUT_SIZE : x / IRIS_MODEL_INPUT_SIZE) * eyeBoxSize[0] + eyeBox.startPoint[0], y / IRIS_MODEL_INPUT_SIZE * eyeBoxSize[1] + eyeBox.startPoint[1], z]);\n    }\n\n    return {\n      rawCoords: eyeRawCoords,\n      iris: eyeRawCoords.slice(IRIS_IRIS_INDEX)\n    };\n  }; // The z-coordinates returned for the iris are unreliable, so we take the z\n  // values from the surrounding keypoints.\n\n\n  Pipeline.prototype.getAdjustedIrisCoords = function (rawCoords, irisCoords, direction) {\n    var upperCenterZ = rawCoords[keypoints_1.MESH_ANNOTATIONS[direction + \"EyeUpper0\"][IRIS_UPPER_CENTER_INDEX]][2];\n    var lowerCenterZ = rawCoords[keypoints_1.MESH_ANNOTATIONS[direction + \"EyeLower0\"][IRIS_LOWER_CENTER_INDEX]][2];\n    var averageZ = (upperCenterZ + lowerCenterZ) / 2; // Iris indices:\n    // 0: center | 1: right | 2: above | 3: left | 4: below\n\n    return irisCoords.map(function (coord, i) {\n      var z = averageZ;\n\n      if (i === 2) {\n        z = upperCenterZ;\n      } else if (i === 4) {\n        z = lowerCenterZ;\n      }\n\n      return [coord[0], coord[1], z];\n    });\n  };\n  /**\n   * Returns an array of predictions for each face in the input.\n   * @param input - tensor of shape [1, H, W, 3].\n   * @param predictIrises - Whether to return keypoints for the irises.\n   */\n\n\n  Pipeline.prototype.predict = function (input, predictIrises) {\n    return __awaiter(this, void 0, void 0, function () {\n      var returnTensors, annotateFace, _a, boxes, scaleFactor_1, scaledBoxes;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this.shouldUpdateRegionsOfInterest()) return [3\n            /*break*/\n            , 2];\n            returnTensors = false;\n            annotateFace = true;\n            return [4\n            /*yield*/\n            , this.boundingBoxDetector.getBoundingBoxes(input, returnTensors, annotateFace)];\n\n          case 1:\n            _a = _b.sent(), boxes = _a.boxes, scaleFactor_1 = _a.scaleFactor;\n\n            if (boxes.length === 0) {\n              this.regionsOfInterest = [];\n              return [2\n              /*return*/\n              , null];\n            }\n\n            scaledBoxes = boxes.map(function (prediction) {\n              var predictionBoxCPU = {\n                startPoint: tf.squeeze(prediction.box.startPoint).arraySync(),\n                endPoint: tf.squeeze(prediction.box.endPoint).arraySync()\n              };\n              var scaledBox = box_1.scaleBoxCoordinates(predictionBoxCPU, scaleFactor_1);\n              var enlargedBox = box_1.enlargeBox(scaledBox);\n              var squarifiedBox = box_1.squarifyBox(enlargedBox);\n              return __assign({}, squarifiedBox, {\n                landmarks: prediction.landmarks.arraySync()\n              });\n            });\n            boxes.forEach(function (box) {\n              if (box != null && box.startPoint != null) {\n                box.startEndTensor.dispose();\n                box.startPoint.dispose();\n                box.endPoint.dispose();\n              }\n            });\n            this.updateRegionsOfInterest(scaledBoxes);\n            this.runsWithoutFaceDetector = 0;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            this.runsWithoutFaceDetector++;\n            _b.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , tf.tidy(function () {\n              return _this.regionsOfInterest.map(function (box, i) {\n                var angle = 0; // The facial bounding box landmarks could come either from blazeface\n                // (if we are using a fresh box), or from the mesh model (if we are\n                // reusing an old box).\n\n                var boxLandmarksFromMeshModel = box.landmarks.length >= LANDMARKS_COUNT;\n                var indexOfMouth = MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[0],\n                    indexOfForehead = MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[1];\n\n                if (boxLandmarksFromMeshModel === false) {\n                  indexOfMouth = BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[0], indexOfForehead = BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES[1];\n                }\n\n                angle = util_1.computeRotation(box.landmarks[indexOfMouth], box.landmarks[indexOfForehead]);\n                var faceCenter = box_1.getBoxCenter({\n                  startPoint: box.startPoint,\n                  endPoint: box.endPoint\n                });\n                var faceCenterNormalized = [faceCenter[0] / input.shape[2], faceCenter[1] / input.shape[1]];\n                var rotatedImage = input;\n                var rotationMatrix = util_1.IDENTITY_MATRIX;\n\n                if (angle !== 0) {\n                  rotatedImage = tf.image.rotateWithOffset(input, angle, 0, faceCenterNormalized);\n                  rotationMatrix = util_1.buildRotationMatrix(-angle, faceCenter);\n                }\n\n                var boxCPU = {\n                  startPoint: box.startPoint,\n                  endPoint: box.endPoint\n                };\n                var face = tf.div(box_1.cutBoxFromImageAndResize(boxCPU, rotatedImage, [_this.meshHeight, _this.meshWidth]), 255); // The first returned tensor represents facial contours, which are\n                // included in the coordinates.\n\n                var _a = _this.meshDetector.predict(face),\n                    flag = _a[1],\n                    coords = _a[2];\n\n                var coordsReshaped = tf.reshape(coords, [-1, 3]);\n                var rawCoords = coordsReshaped.arraySync();\n\n                if (predictIrises) {\n                  var _b = _this.getEyeBox(rawCoords, face, LEFT_EYE_BOUNDS[0], LEFT_EYE_BOUNDS[1], true),\n                      leftEyeBox = _b.box,\n                      leftEyeBoxSize = _b.boxSize,\n                      leftEyeCrop = _b.crop;\n\n                  var _c = _this.getEyeBox(rawCoords, face, RIGHT_EYE_BOUNDS[0], RIGHT_EYE_BOUNDS[1]),\n                      rightEyeBox = _c.box,\n                      rightEyeBoxSize = _c.boxSize,\n                      rightEyeCrop = _c.crop;\n\n                  var eyePredictions = _this.irisModel.predict(tf.concat([leftEyeCrop, rightEyeCrop]));\n\n                  var eyePredictionsData = eyePredictions.dataSync();\n                  var leftEyeData = eyePredictionsData.slice(0, IRIS_NUM_COORDINATES * 3);\n\n                  var _d = _this.getEyeCoords(leftEyeData, leftEyeBox, leftEyeBoxSize, true),\n                      leftEyeRawCoords = _d.rawCoords,\n                      leftIrisRawCoords = _d.iris;\n\n                  var rightEyeData = eyePredictionsData.slice(IRIS_NUM_COORDINATES * 3);\n\n                  var _e = _this.getEyeCoords(rightEyeData, rightEyeBox, rightEyeBoxSize),\n                      rightEyeRawCoords = _e.rawCoords,\n                      rightIrisRawCoords = _e.iris;\n\n                  var leftToRightEyeDepthDifference = _this.getLeftToRightEyeDepthDifference(rawCoords);\n\n                  if (Math.abs(leftToRightEyeDepthDifference) < 30) {\n                    // User is looking straight ahead.\n                    replaceRawCoordinates(rawCoords, leftEyeRawCoords, 'left');\n                    replaceRawCoordinates(rawCoords, rightEyeRawCoords, 'right');\n                  } else if (leftToRightEyeDepthDifference < 1) {\n                    // User is looking\n                    // towards the\n                    // right.\n                    // If the user is looking to the left or to the right, the iris\n                    // coordinates tend to diverge too much from the mesh coordinates\n                    // for them to be merged. So we only update a single contour line\n                    // above and below the eye.\n                    replaceRawCoordinates(rawCoords, leftEyeRawCoords, 'left', ['EyeUpper0', 'EyeLower0']);\n                  } else {\n                    // User is looking towards the left.\n                    replaceRawCoordinates(rawCoords, rightEyeRawCoords, 'right', ['EyeUpper0', 'EyeLower0']);\n                  }\n\n                  var adjustedLeftIrisCoords = _this.getAdjustedIrisCoords(rawCoords, leftIrisRawCoords, 'left');\n\n                  var adjustedRightIrisCoords = _this.getAdjustedIrisCoords(rawCoords, rightIrisRawCoords, 'right');\n\n                  rawCoords = rawCoords.concat(adjustedLeftIrisCoords).concat(adjustedRightIrisCoords);\n                }\n\n                var transformedCoordsData = _this.transformRawCoords(rawCoords, box, angle, rotationMatrix);\n\n                var transformedCoords = tf.tensor2d(transformedCoordsData);\n                var landmarksBox = box_1.enlargeBox(_this.calculateLandmarksBoundingBox(transformedCoordsData));\n                var squarifiedLandmarksBox = box_1.squarifyBox(landmarksBox);\n                _this.regionsOfInterest[i] = __assign({}, squarifiedLandmarksBox, {\n                  landmarks: transformedCoords.arraySync()\n                });\n                var prediction = {\n                  coords: tf.tensor2d(rawCoords, [rawCoords.length, 3]),\n                  scaledCoords: transformedCoords,\n                  box: landmarksBox,\n                  flag: tf.squeeze(flag)\n                };\n                return prediction;\n              });\n            })];\n        }\n      });\n    });\n  }; // Updates regions of interest if the intersection over union between\n  // the incoming and previous regions falls below a threshold.\n\n\n  Pipeline.prototype.updateRegionsOfInterest = function (boxes) {\n    for (var i = 0; i < boxes.length; i++) {\n      var box = boxes[i];\n      var previousBox = this.regionsOfInterest[i];\n      var iou = 0;\n\n      if (previousBox && previousBox.startPoint) {\n        var _a = box.startPoint,\n            boxStartX = _a[0],\n            boxStartY = _a[1];\n        var _b = box.endPoint,\n            boxEndX = _b[0],\n            boxEndY = _b[1];\n        var _c = previousBox.startPoint,\n            previousBoxStartX = _c[0],\n            previousBoxStartY = _c[1];\n        var _d = previousBox.endPoint,\n            previousBoxEndX = _d[0],\n            previousBoxEndY = _d[1];\n        var xStartMax = Math.max(boxStartX, previousBoxStartX);\n        var yStartMax = Math.max(boxStartY, previousBoxStartY);\n        var xEndMin = Math.min(boxEndX, previousBoxEndX);\n        var yEndMin = Math.min(boxEndY, previousBoxEndY);\n        var intersection = (xEndMin - xStartMax) * (yEndMin - yStartMax);\n        var boxArea = (boxEndX - boxStartX) * (boxEndY - boxStartY);\n        var previousBoxArea = (previousBoxEndX - previousBoxStartX) * (previousBoxEndY - boxStartY);\n        iou = intersection / (boxArea + previousBoxArea - intersection);\n      }\n\n      if (iou < UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD) {\n        this.regionsOfInterest[i] = box;\n      }\n    }\n\n    this.regionsOfInterest = this.regionsOfInterest.slice(0, boxes.length);\n  };\n\n  Pipeline.prototype.clearRegionOfInterest = function (index) {\n    if (this.regionsOfInterest[index] != null) {\n      this.regionsOfInterest = this.regionsOfInterest.slice(0, index).concat(this.regionsOfInterest.slice(index + 1));\n    }\n  };\n\n  Pipeline.prototype.shouldUpdateRegionsOfInterest = function () {\n    var roisCount = this.regionsOfInterest.length;\n    var noROIs = roisCount === 0;\n\n    if (this.maxFaces === 1 || noROIs) {\n      return noROIs;\n    }\n\n    return roisCount !== this.maxFaces && this.runsWithoutFaceDetector >= this.maxContinuousChecks;\n  };\n\n  Pipeline.prototype.calculateLandmarksBoundingBox = function (landmarks) {\n    var xs = landmarks.map(function (d) {\n      return d[0];\n    });\n    var ys = landmarks.map(function (d) {\n      return d[1];\n    });\n    var startPoint = [Math.min.apply(Math, xs), Math.min.apply(Math, ys)];\n    var endPoint = [Math.max.apply(Math, xs), Math.max.apply(Math, ys)];\n    return {\n      startPoint: startPoint,\n      endPoint: endPoint\n    };\n  };\n\n  return Pipeline;\n}();\n\nexports.Pipeline = Pipeline;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;;AAEA;;AACA;;AACA;;AASA,IAAMA,eAAe,GAAG,GAAxB;AACA,IAAMC,uCAAuC,GAAG,IAAhD;AAEA,IAAMC,gBAAgB,GAAG,EAAzB;AACA,IAAMC,uCAAuC,GACzC,CAACD,gBAAD,EAAmBE,6BAAiB,mBAAjB,EAAsC,CAAtC,CAAnB,CADJ;AAGA,IAAMC,qBAAqB,GAAG,CAA9B;AACA,IAAMC,oBAAoB,GAAG,CAA7B;AACA,IAAMC,4CAA4C,GAC9C,CAACF,qBAAD,EAAwBC,oBAAxB,CADJ;AAGA,IAAME,gBAAgB,GAAGJ,6BAAiB,eAAjB,CAAzB;AACA,IAAMK,eAAe,GACjB,CAACD,gBAAgB,CAAC,CAAD,CAAjB,EAAsBA,gBAAgB,CAACA,gBAAgB,CAACE,MAAjB,GAA0B,CAA3B,CAAtC,CADJ;AAEA,IAAMC,iBAAiB,GAAGP,6BAAiB,gBAAjB,CAA1B;AACA,IAAMQ,gBAAgB,GAClB,CAACD,iBAAiB,CAAC,CAAD,CAAlB,EAAuBA,iBAAiB,CAACA,iBAAiB,CAACD,MAAlB,GAA2B,CAA5B,CAAxC,CADJ;AAGA,IAAMG,uBAAuB,GAAG,CAAhC;AACA,IAAMC,uBAAuB,GAAG,CAAhC;AACA,IAAMC,eAAe,GAAG,EAAxB;AACA,IAAMC,oBAAoB,GAAG,EAA7B,C,CAEA;AACA;;AACA,IAAMC,iBAAiB,GAAG,GAA1B;AACA,IAAMC,qBAAqB,GAAG,EAA9B,C,CAEA;;AACA,IAAMC,wBAAwB,GAAG,CAC/B;AAACC,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,EAAY,EAAZ,EAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB;AAA5B,CAD+B,EAE/B;AAACD,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB;AAA5B,CAF+B,EAG/B;AAACD,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB;AAA5B,CAH+B,EAI/B;AAACD,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB;AAA5B,CAJ+B,EAK/B;AAACD,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC;AAA5B,CAL+B,EAM/B;AAACD,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC;AAA5B,CAN+B,EAO/B;AAACD,KAAG,EAAE,WAAN;AAAmBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC;AAA5B,CAP+B,EAQ/B;AAACD,KAAG,EAAE,cAAN;AAAsBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B;AAA/B,CAR+B,EAS/B;AAACD,KAAG,EAAE,cAAN;AAAsBC,SAAO,EAAE,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB;AAA/B,CAT+B,CAAjC,C,CAYA;AACA;AACA;AACA;;AACA,SAASC,qBAAT,CACIC,SADJ,EACyBC,SADzB,EAC8CC,MAD9C,EAC8DC,IAD9D,EAC6E;AAC3E,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,wBAAwB,CAACT,MAA7C,EAAqDiB,CAAC,EAAtD,EAA0D;AAClD;AAAA,QAACP,YAAD;AAAA,QAAMC,oBAAN;AACN,QAAMO,eAAe,GAAGxB,6BAAiB,KAAGqB,MAAH,GAAYL,GAA7B,CAAxB;AAEA,QAAMS,oBAAoB,GAAGH,IAAI,IAAI,IAArC;;AACA,QAAIG,oBAAoB,IAAIH,IAAI,CAACI,QAAL,CAAcV,GAAd,CAA5B,EAAgD;AAC9C,WAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,OAAO,CAACX,MAA5B,EAAoCqB,CAAC,EAArC,EAAyC;AACvC,YAAMC,KAAK,GAAGX,OAAO,CAACU,CAAD,CAArB;AAEAR,iBAAS,CAACK,eAAe,CAACG,CAAD,CAAhB,CAAT,GAAgC,CAC9BP,SAAS,CAACQ,KAAD,CAAT,CAAiB,CAAjB,CAD8B,EACTR,SAAS,CAACQ,KAAD,CAAT,CAAiB,CAAjB,CADS,EAE9B,CAACR,SAAS,CAACQ,KAAD,CAAT,CAAiB,CAAjB,IAAsBT,SAAS,CAACK,eAAe,CAACG,CAAD,CAAhB,CAAT,CAA8B,CAA9B,CAAvB,IAA2D,CAF7B,CAAhC;AAID;AACF;AACF;AACF,C,CAED;;;AACA;AAAA;AAAA;AAiBE,oBACIE,mBADJ,EAEIC,YAFJ,EAEqCC,SAFrC,EAEwDC,UAFxD,EAGIC,mBAHJ,EAGiCC,QAHjC,EAIIC,SAJJ,EAIqC;AARrC;AACQ,6BAA2B,EAA3B;AACA,mCAA0B,CAA1B;AAON,SAAKN,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKK,SAAL,GAAiBA,SAAjB;AACA,SAAKJ,SAAL,GAAiBA,SAAjB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;AAEDE,oDACIjB,SADJ,EACyBkB,GADzB,EACmCC,KADnC,EAEIC,cAFJ,EAEwC;AAFxC;;AAGE,QAAMC,OAAO,GACTC,iBAAW;AAACC,gBAAU,EAAEL,GAAG,CAACK,UAAjB;AAA6BC,cAAQ,EAAEN,GAAG,CAACM;AAA3C,KAAX,CADJ;AAEA,QAAMC,WAAW,GACb,CAACJ,OAAO,CAAC,CAAD,CAAP,GAAa,KAAKT,SAAnB,EAA8BS,OAAO,CAAC,CAAD,CAAP,GAAa,KAAKR,UAAhD,CADJ;AAEA,QAAMa,YAAY,GAAG1B,SAAS,CAAC2B,GAAV,CACjB,iBAAK;AAAI,aAAC,CACRF,WAAW,CAAC,CAAD,CAAX,IAAkBG,KAAK,CAAC,CAAD,CAAL,GAAWC,KAAI,CAACjB,SAAL,GAAiB,CAA9C,CADQ,EAERa,WAAW,CAAC,CAAD,CAAX,IAAkBG,KAAK,CAAC,CAAD,CAAL,GAAWC,KAAI,CAAChB,UAAL,GAAkB,CAA/C,CAFQ,EAE2Ce,KAAK,CAAC,CAAD,CAFhD,CAAD;AAGP,KAJe,CAArB;AAMA,QAAME,oBAAoB,GAAGC,2BAAoBZ,KAApB,EAA2B,CAAC,CAAD,EAAI,CAAJ,CAA3B,CAA7B;AACA,QAAMa,aAAa,GAAGN,YAAY,CAACC,GAAb,CAClB,UAACC,KAAD,EAAe;AACX,aAAKG,mBAAYH,KAAZ,EAAmBE,oBAAnB,EAAwCG,MAAxC,CAAwC,CAAEL,KAAK,CAAC,CAAD,CAAP,CAAxC,CAAL;AAAyD,KAF3C,CAAtB;AAIA,QAAMM,qBAAqB,GAAGH,6BAAsBX,cAAtB,CAA9B;AACA,QAAMe,SAAS,GACVb,mBAAa;AAACC,gBAAU,EAAEL,GAAG,CAACK,UAAjB;AAA6BC,cAAQ,EAAEN,GAAG,CAACM;AAA3C,KAAb,EAAkES,MAAlE,CAAkE,CAAE,CAAF,CAAlE,CADL;AAIA,QAAMG,iBAAiB,GAAG,CACxBL,WAAII,SAAJ,EAAeD,qBAAqB,CAAC,CAAD,CAApC,CADwB,EAExBH,WAAII,SAAJ,EAAeD,qBAAqB,CAAC,CAAD,CAApC,CAFwB,CAA1B;AAKA,WAAOF,aAAa,CAACL,GAAd,CAAkB,UAACC,KAAD,EAAM;AAAc,aAAC,CACnBA,KAAK,CAAC,CAAD,CAAL,GAAWQ,iBAAiB,CAAC,CAAD,CADT,EAEnBR,KAAK,CAAC,CAAD,CAAL,GAAWQ,iBAAiB,CAAC,CAAD,CAFT,EAEcR,KAAK,CAAC,CAAD,CAFnB,CAAD;AAGlB,KAHpB,CAAP;AAID,GAhCD;;AAkCQX,wDAAR,UAAyCjB,SAAzC,EAA4D;AAC1D,QAAMqC,QAAQ,GAAGrC,SAAS,CAACd,eAAe,CAAC,CAAD,CAAhB,CAAT,CAA8B,CAA9B,CAAjB;AACA,QAAMoD,SAAS,GAAGtC,SAAS,CAACX,gBAAgB,CAAC,CAAD,CAAjB,CAAT,CAA+B,CAA/B,CAAlB;AACA,WAAOgD,QAAQ,GAAGC,SAAlB;AACD,GAJO,CAjEV,CAuEE;AACA;;;AACArB,2CACIjB,SADJ,EACyBuC,IADzB,EAC4CC,mBAD5C,EAEIC,mBAFJ,EAGIC,IAHJ,EAGgB;AAAZ;AAAAA;AAAY;;AACd,QAAMxB,GAAG,GAAGI,kBAAYA,iBACpB,KAAKqB,6BAAL,CACI,CAAC3C,SAAS,CAACwC,mBAAD,CAAV,EAAiCxC,SAAS,CAACyC,mBAAD,CAA1C,CADJ,CADoB,EAGpB/C,iBAHoB,CAAZ,CAAZ;AAIA,QAAM2B,OAAO,GAAGC,iBAAWJ,GAAX,CAAhB;AACA,QAAI0B,IAAI,GAAGC,EAAE,CAACC,KAAH,CAASC,aAAT,CACPR,IADO,EACD,CAAC,CACLrB,GAAG,CAACK,UAAJ,CAAe,CAAf,IAAoB,KAAKV,UADpB,EAELK,GAAG,CAACK,UAAJ,CAAe,CAAf,IAAoB,KAAKX,SAFpB,EAE+BM,GAAG,CAACM,QAAJ,CAAa,CAAb,IAAkB,KAAKX,UAFtD,EAGLK,GAAG,CAACM,QAAJ,CAAa,CAAb,IAAkB,KAAKZ,SAHlB,CAAD,CADC,EAMP,CAAC,CAAD,CANO,EAMF,CAACjB,qBAAD,EAAwBA,qBAAxB,CANE,CAAX;;AAOA,QAAI+C,IAAJ,EAAU;AACRE,UAAI,GAAGC,EAAE,CAACC,KAAH,CAASE,aAAT,CAAuBJ,IAAvB,CAAP;AACD;;AAED,WAAO;AAAC1B,SAAG,KAAJ;AAAMG,aAAO,SAAb;AAAeuB,UAAI;AAAnB,KAAP;AACD,GArBD,CAzEF,CAgGE;AACA;;;AACA3B,8CACIgC,OADJ,EAC2BC,MAD3B,EACwCC,UADxC,EAEIT,IAFJ,EAEgB;AAAZ;AAAAA;AAAY;;AACd,QAAMU,YAAY,GAAa,EAA/B;;AACA,SAAK,IAAIhD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,oBAApB,EAA0CW,CAAC,EAA3C,EAA+C;AAC7C,UAAMiD,CAAC,GAAGJ,OAAO,CAAC7C,CAAC,GAAG,CAAL,CAAjB;AACA,UAAMkD,CAAC,GAAGL,OAAO,CAAC7C,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAjB;AACA,UAAMmD,CAAC,GAAGN,OAAO,CAAC7C,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAjB;AACAgD,kBAAY,CAACI,IAAb,CAAkB,CAChB,CAACd,IAAI,GAAI,IAAKW,CAAC,GAAG1D,qBAAb,GACI0D,CAAC,GAAG1D,qBADb,IAEQwD,UAAU,CAAC,CAAD,CAFlB,GAGID,MAAM,CAAC3B,UAAP,CAAkB,CAAlB,CAJY,EAKf+B,CAAC,GAAG3D,qBAAL,GAA8BwD,UAAU,CAAC,CAAD,CAAxC,GAA8CD,MAAM,CAAC3B,UAAP,CAAkB,CAAlB,CAL9B,EAKoDgC,CALpD,CAAlB;AAOD;;AAED,WAAO;AAACvD,eAAS,EAAEoD,YAAZ;AAA0BK,UAAI,EAAEL,YAAY,CAACM,KAAb,CAAmBlE,eAAnB;AAAhC,KAAP;AACD,GAlBD,CAlGF,CAsHE;AACA;;;AACQyB,6CAAR,UACIjB,SADJ,EACyB2D,UADzB,EAEIC,SAFJ,EAE6B;AAC3B,QAAMC,YAAY,GACd7D,SAAS,CAACnB,6BAAoB+E,SAAS,cAA7B,EACiBtE,uBADjB,CAAD,CAAT,CACqD,CADrD,CADJ;AAGA,QAAMwE,YAAY,GACd9D,SAAS,CAACnB,6BAAoB+E,SAAS,cAA7B,EACiBrE,uBADjB,CAAD,CAAT,CACqD,CADrD,CADJ;AAGA,QAAMwE,QAAQ,GAAG,CAACF,YAAY,GAAGC,YAAhB,IAAgC,CAAjD,CAP2B,CAS3B;AACA;;AACA,WAAOH,UAAU,CAAChC,GAAX,CAAe,UAACC,KAAD,EAAiBxB,CAAjB,EAAkB;AACtC,UAAImD,CAAC,GAAGQ,QAAR;;AACA,UAAI3D,CAAC,KAAK,CAAV,EAAa;AACXmD,SAAC,GAAGM,YAAJ;AACD,OAFD,MAEO,IAAIzD,CAAC,KAAK,CAAV,EAAa;AAClBmD,SAAC,GAAGO,YAAJ;AACD;;AACD,aAAO,CAAClC,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqB2B,CAArB,CAAP;AACD,KARM,CAAP;AASD,GAtBO;AAwBR;;;;;;;AAKMtC,+BAAN,UAAc+C,KAAd,EAAkCC,aAAlC,EAAwD;;;;;;;;;iBAElD,KAAKC,6BAAL;AAAA;AAAA;AACIC,yBAAa,GAAG,KAAhB;AACAC,wBAAY,GAAG,IAAf;AAEF;AAAA;AAAA,cAAM,KAAK1D,mBAAL,CAAyB2D,gBAAzB,CACFL,KADE,EACKG,aADL,EACoBC,YADpB,CAAN;;;AADEE,iBACFC,SADE,EAACC,KAAK,WAAN,EAAQC,8BAAR;;AAIN,gBAAID,KAAK,CAACrF,MAAN,KAAiB,CAArB,EAAwB;AACtB,mBAAKuF,iBAAL,GAAyB,EAAzB;AACA;AAAA;AAAA,gBAAO,IAAP;AACD;;AAEKC,uBAAW,GACbH,KAAK,CAAC7C,GAAN,CAAU,UAACiD,UAAD,EAA0C;AAClD,kBAAMC,gBAAgB,GAAG;AACvBtD,0BAAU,EAAEsB,EAAE,CAACiC,OAAH,CAAWF,UAAU,CAAC1D,GAAX,CAAeK,UAA1B,EAAsCwD,SAAtC,EADW;AAGvBvD,wBAAQ,EAAEqB,EAAE,CAACiC,OAAH,CAAWF,UAAU,CAAC1D,GAAX,CAAeM,QAA1B,EAAoCuD,SAApC;AAHa,eAAzB;AAMA,kBAAMC,SAAS,GACX1D,0BAAoBuD,gBAApB,EAAsCJ,aAAtC,CADJ;AAEA,kBAAMQ,WAAW,GAAG3D,iBAAW0D,SAAX,CAApB;AACA,kBAAME,aAAa,GAAG5D,kBAAY2D,WAAZ,CAAtB;AACA,kCACKC,aADL,EACkB;AAChBC,yBAAS,EAAEP,UAAU,CAACO,SAAX,CAAqBJ,SAArB;AADK,eADlB;AAID,aAfD,CADE;AAkBNP,iBAAK,CAACY,OAAN,CAAc,UAAClE,GAAD,EAIC;AACb,kBAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACK,UAAJ,IAAkB,IAArC,EAA2C;AACzCL,mBAAG,CAACmE,cAAJ,CAAmBC,OAAnB;AACApE,mBAAG,CAACK,UAAJ,CAAe+D,OAAf;AACApE,mBAAG,CAACM,QAAJ,CAAa8D,OAAb;AACD;AACF,aAVD;AAYA,iBAAKC,uBAAL,CAA6BZ,WAA7B;AACA,iBAAKa,uBAAL,GAA+B,CAA/B;;;;;;AAEA,iBAAKA,uBAAL;;;;AAGF;AAAA;AAAA,cAAO3C,EAAE,CAAC4C,IAAH,CAAQ;AACb,qBAAO5D,KAAI,CAAC6C,iBAAL,CAAuB/C,GAAvB,CAA2B,UAACT,GAAD,EAAMd,CAAN,EAAO;AACvC,oBAAIe,KAAK,GAAG,CAAZ,CADuC,CAEvC;AACA;AACA;;AACA,oBAAMuE,yBAAyB,GAC3BxE,GAAG,CAACiE,SAAJ,CAAchG,MAAd,IAAwBV,eAD5B;AAEK;AAAA,oBAAckH,4DAAd;;AAGL,oBAAID,yBAAyB,KAAK,KAAlC,EAAyC;AACtCE,kFAAcD,iEAAd;AAEF;;AAEDxE,qBAAK,GAAGY,uBACJb,GAAG,CAACiE,SAAJ,CAAcS,YAAd,CADI,EACyB1E,GAAG,CAACiE,SAAJ,CAAcQ,eAAd,CADzB,CAAR;AAGA,oBAAME,UAAU,GACZvE,mBAAa;AAACC,4BAAU,EAAEL,GAAG,CAACK,UAAjB;AAA6BC,0BAAQ,EAAEN,GAAG,CAACM;AAA3C,iBAAb,CADJ;AAEA,oBAAMsE,oBAAoB,GACtB,CAACD,UAAU,CAAC,CAAD,CAAV,GAAgB7B,KAAK,CAAC+B,KAAN,CAAY,CAAZ,CAAjB,EAAiCF,UAAU,CAAC,CAAD,CAAV,GAAgB7B,KAAK,CAAC+B,KAAN,CAAY,CAAZ,CAAjD,CADJ;AAGA,oBAAIC,YAAY,GAAGhC,KAAnB;AACA,oBAAI5C,cAAc,GAAGW,sBAArB;;AACA,oBAAIZ,KAAK,KAAK,CAAd,EAAiB;AACf6E,8BAAY,GACRnD,EAAE,CAACC,KAAH,CAASmD,gBAAT,CAA0BjC,KAA1B,EAAiC7C,KAAjC,EAAwC,CAAxC,EAA2C2E,oBAA3C,CADJ;AAEA1E,gCAAc,GAAGW,2BAAoB,CAACZ,KAArB,EAA4B0E,UAA5B,CAAjB;AACD;;AAED,oBAAMK,MAAM,GAAG;AAAC3E,4BAAU,EAAEL,GAAG,CAACK,UAAjB;AAA6BC,0BAAQ,EAAEN,GAAG,CAACM;AAA3C,iBAAf;AACA,oBAAMe,IAAI,GACNM,EAAE,CAACsD,GAAH,CAAO7E,+BAAyB4E,MAAzB,EAAiCF,YAAjC,EAA+C,CACpDnE,KAAI,CAAChB,UAD+C,EACnCgB,KAAI,CAACjB,SAD8B,CAA/C,CAAP,EAEI,GAFJ,CADJ,CAhCuC,CAqCvC;AACA;;AACM;AAAA,oBAAGwF,YAAH;AAAA,oBAASC,cAAT;;AAIN,oBAAMC,cAAc,GAAgBzD,EAAE,CAAC0D,OAAH,CAAWF,MAAX,EAAmB,CAAC,CAAC,CAAF,EAAK,CAAL,CAAnB,CAApC;AACA,oBAAIrG,SAAS,GAAGsG,cAAc,CAACvB,SAAf,EAAhB;;AAEA,oBAAId,aAAJ,EAAmB;AACX;AAAA,sBAACuC,mBAAD;AAAA,sBAAkBC,2BAAlB;AAAA,sBAA2CC,qBAA3C;;AAIA;AAAA,sBACJC,oBADI;AAAA,sBAEJC,4BAFI;AAAA,sBAGJC,sBAHI;;AAQN,sBAAMC,cAAc,GACfjF,KAAI,CAACb,SAAL,CAAe+F,OAAf,CACGlE,EAAE,CAACZ,MAAH,CAAU,CAACyE,WAAD,EAAcG,YAAd,CAAV,CADH,CADL;;AAGA,sBAAMG,kBAAkB,GAAGF,cAAc,CAACG,QAAf,EAA3B;AAEA,sBAAMC,WAAW,GACbF,kBAAkB,CAACtD,KAAnB,CAAyB,CAAzB,EAA4BjE,oBAAoB,GAAG,CAAnD,CADJ;;AAEM;AAAA,sBAAC0H,+BAAD;AAAA,sBAA8BC,2BAA9B;;AAGN,sBAAMC,YAAY,GACdL,kBAAkB,CAACtD,KAAnB,CAAyBjE,oBAAoB,GAAG,CAAhD,CADJ;;AAEM;AAAA,sBAAC6H,gCAAD;AAAA,sBAA+BC,4BAA/B;;AAGN,sBAAMC,6BAA6B,GAC/B3F,KAAI,CAAC4F,gCAAL,CAAsCzH,SAAtC,CADJ;;AAEA,sBAAI0H,IAAI,CAACC,GAAL,CAASH,6BAAT,IACA,EADJ,EACQ;AAAG;AACTzH,yCAAqB,CAACC,SAAD,EAAYmH,gBAAZ,EAA8B,MAA9B,CAArB;AACApH,yCAAqB,CAACC,SAAD,EAAYsH,iBAAZ,EAA+B,OAA/B,CAArB;AACD,mBAJD,MAIO,IAAIE,6BAA6B,GAAG,CAApC,EAAuC;AAAG;AACA;AACA;AAC/C;AACA;AACA;AACA;AACAzH,yCAAqB,CACjBC,SADiB,EACNmH,gBADM,EACY,MADZ,EAEjB,CAAC,WAAD,EAAc,WAAd,CAFiB,CAArB;AAGD,mBAVM,MAUA;AAAG;AACRpH,yCAAqB,CACjBC,SADiB,EACNsH,iBADM,EACa,OADb,EAEjB,CAAC,WAAD,EAAc,WAAd,CAFiB,CAArB;AAGD;;AAED,sBAAMM,sBAAsB,GACxB/F,KAAI,CAACgG,qBAAL,CAA2B7H,SAA3B,EAAsCoH,iBAAtC,EAAyD,MAAzD,CADJ;;AAEA,sBAAMU,uBAAuB,GAAGjG,KAAI,CAACgG,qBAAL,CAC5B7H,SAD4B,EACjBuH,kBADiB,EACG,OADH,CAAhC;;AAEAvH,2BAAS,GAAGA,SAAS,CAACiC,MAAV,CAAiB2F,sBAAjB,EACK3F,MADL,CACY6F,uBADZ,CAAZ;AAED;;AAED,oBAAMC,qBAAqB,GACvBlG,KAAI,CAACmG,kBAAL,CAAwBhI,SAAxB,EAAmCkB,GAAnC,EAAwCC,KAAxC,EAA+CC,cAA/C,CADJ;;AAEA,oBAAM6G,iBAAiB,GAAGpF,EAAE,CAACqF,QAAH,CAAYH,qBAAZ,CAA1B;AAEA,oBAAMI,YAAY,GAAG7G,iBACjBO,KAAI,CAACc,6BAAL,CAAmCoF,qBAAnC,CADiB,CAArB;AAEA,oBAAMK,sBAAsB,GAAG9G,kBAAY6G,YAAZ,CAA/B;AACAtG,qBAAI,CAAC6C,iBAAL,CAAuBtE,CAAvB,IAAyBiI,aACpBD,sBADoB,EACE;AACzBjD,2BAAS,EAAE8C,iBAAiB,CAAClD,SAAlB;AADc,iBADF,CAAzB;AAKA,oBAAMH,UAAU,GAAe;AAC7ByB,wBAAM,EAAExD,EAAE,CAACqF,QAAH,CAAYlI,SAAZ,EAAuB,CAACA,SAAS,CAACb,MAAX,EAAmB,CAAnB,CAAvB,CADqB;AAE7BmJ,8BAAY,EAAEL,iBAFe;AAG7B/G,qBAAG,EAAEiH,YAHwB;AAI7B/B,sBAAI,EAAEvD,EAAE,CAACiC,OAAH,CAAWsB,IAAX;AAJuB,iBAA/B;AAOA,uBAAOxB,UAAP;AACD,eA5HM,CAAP;AA6HD,aA9HM,CAAP;;;;AA+HD,GAjLK,CArJR,CAwUE;AACA;;;AACA3D,yDAAwBuD,KAAxB,EAAoC;AAClC,SAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoE,KAAK,CAACrF,MAA1B,EAAkCiB,CAAC,EAAnC,EAAuC;AACrC,UAAMc,GAAG,GAAGsD,KAAK,CAACpE,CAAD,CAAjB;AACA,UAAMmI,WAAW,GAAG,KAAK7D,iBAAL,CAAuBtE,CAAvB,CAApB;AACA,UAAIoI,GAAG,GAAG,CAAV;;AAEA,UAAID,WAAW,IAAIA,WAAW,CAAChH,UAA/B,EAA2C;AACnC;AAAA,YAACkH,iBAAD;AAAA,YAAYC,iBAAZ;AACA;AAAA,YAACC,eAAD;AAAA,YAAUC,eAAV;AACA;AAAA,YAACC,yBAAD;AAAA,YAAoBC,yBAApB;AACA;AAAA,YAACC,uBAAD;AAAA,YAAkBC,uBAAlB;AAEN,YAAMC,SAAS,GAAGvB,IAAI,CAACwB,GAAL,CAAST,SAAT,EAAoBI,iBAApB,CAAlB;AACA,YAAMM,SAAS,GAAGzB,IAAI,CAACwB,GAAL,CAASR,SAAT,EAAoBI,iBAApB,CAAlB;AACA,YAAMM,OAAO,GAAG1B,IAAI,CAAC2B,GAAL,CAASV,OAAT,EAAkBI,eAAlB,CAAhB;AACA,YAAMO,OAAO,GAAG5B,IAAI,CAAC2B,GAAL,CAAST,OAAT,EAAkBI,eAAlB,CAAhB;AAEA,YAAMO,YAAY,GAAG,CAACH,OAAO,GAAGH,SAAX,KAAyBK,OAAO,GAAGH,SAAnC,CAArB;AACA,YAAMK,OAAO,GAAG,CAACb,OAAO,GAAGF,SAAX,KAAyBG,OAAO,GAAGF,SAAnC,CAAhB;AACA,YAAMe,eAAe,GAAG,CAACV,eAAe,GAAGF,iBAAnB,KACnBG,eAAe,GAAGN,SADC,CAAxB;AAEAF,WAAG,GAAGe,YAAY,IAAIC,OAAO,GAAGC,eAAV,GAA4BF,YAAhC,CAAlB;AACD;;AAED,UAAIf,GAAG,GAAG9J,uCAAV,EAAmD;AACjD,aAAKgG,iBAAL,CAAuBtE,CAAvB,IAA4Bc,GAA5B;AACD;AACF;;AAED,SAAKwD,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBhB,KAAvB,CAA6B,CAA7B,EAAgCc,KAAK,CAACrF,MAAtC,CAAzB;AACD,GA9BD;;AAgCA8B,uDAAsBR,KAAtB,EAAmC;AACjC,QAAI,KAAKiE,iBAAL,CAAuBjE,KAAvB,KAAiC,IAArC,EAA2C;AACzC,WAAKiE,iBAAL,GACK,KAAKA,iBAAL,CAAuBhB,KAAvB,CAA6B,CAA7B,EAAgCjD,KAAhC,EAAsCwB,MAAtC,CACA,KAAKyC,iBAAL,CAAuBhB,KAAvB,CAA6BjD,KAAK,GAAG,CAArC,CADA,CADL;AAID;AACF,GAPD;;AASAQ;AACE,QAAMyI,SAAS,GAAG,KAAKhF,iBAAL,CAAuBvF,MAAzC;AACA,QAAMwK,MAAM,GAAGD,SAAS,KAAK,CAA7B;;AAEA,QAAI,KAAK3I,QAAL,KAAkB,CAAlB,IAAuB4I,MAA3B,EAAmC;AACjC,aAAOA,MAAP;AACD;;AAED,WAAOD,SAAS,KAAK,KAAK3I,QAAnB,IACH,KAAKyE,uBAAL,IAAgC,KAAK1E,mBADzC;AAED,GAVD;;AAYAG,+DAA8BkE,SAA9B,EAAiD;AAC/C,QAAMyE,EAAE,GAAGzE,SAAS,CAACxD,GAAV,CAAc,aAAC;AAAI,cAAC,CAAC,CAAD,CAAD;AAAI,KAAvB,CAAX;AACA,QAAMkI,EAAE,GAAG1E,SAAS,CAACxD,GAAV,CAAc,aAAC;AAAI,cAAC,CAAC,CAAD,CAAD;AAAI,KAAvB,CAAX;AAEA,QAAMJ,UAAU,GAAY,CAACmG,IAAI,CAAC2B,GAAL,CAAQS,KAAR,OAAYF,EAAZ,CAAD,EAAkBlC,IAAI,CAAC2B,GAAL,CAAQS,KAAR,OAAYD,EAAZ,CAAlB,CAA5B;AACA,QAAMrI,QAAQ,GAAY,CAACkG,IAAI,CAACwB,GAAL,CAAQY,KAAR,OAAYF,EAAZ,CAAD,EAAkBlC,IAAI,CAACwB,GAAL,CAAQY,KAAR,OAAYD,EAAZ,CAAlB,CAA1B;AACA,WAAO;AAACtI,gBAAU,YAAX;AAAaC,cAAQ;AAArB,KAAP;AACD,GAPD;;AAQF;AAAC,CAvYD;;AAAauI","names":["LANDMARKS_COUNT","UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD","MESH_MOUTH_INDEX","MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES","keypoints_1","BLAZEFACE_MOUTH_INDEX","BLAZEFACE_NOSE_INDEX","BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES","LEFT_EYE_OUTLINE","LEFT_EYE_BOUNDS","length","RIGHT_EYE_OUTLINE","RIGHT_EYE_BOUNDS","IRIS_UPPER_CENTER_INDEX","IRIS_LOWER_CENTER_INDEX","IRIS_IRIS_INDEX","IRIS_NUM_COORDINATES","ENLARGE_EYE_RATIO","IRIS_MODEL_INPUT_SIZE","MESH_TO_IRIS_INDICES_MAP","key","indices","replaceRawCoordinates","rawCoords","newCoords","prefix","keys","i","originalIndices","shouldReplaceAllKeys","includes","j","index","boundingBoxDetector","meshDetector","meshWidth","meshHeight","maxContinuousChecks","maxFaces","irisModel","Pipeline","box","angle","rotationMatrix","boxSize","box_1","startPoint","endPoint","scaleFactor","coordsScaled","map","coord","_this","coordsRotationMatrix","util_1","coordsRotated","concat","inverseRotationMatrix","boxCenter","originalBoxCenter","leftEyeZ","rightEyeZ","face","eyeInnerCornerIndex","eyeOuterCornerIndex","flip","calculateLandmarksBoundingBox","crop","tf","image","cropAndResize","flipLeftRight","eyeData","eyeBox","eyeBoxSize","eyeRawCoords","x","y","z","push","iris","slice","irisCoords","direction","upperCenterZ","lowerCenterZ","averageZ","input","predictIrises","shouldUpdateRegionsOfInterest","returnTensors","annotateFace","getBoundingBoxes","_a","_b","boxes","scaleFactor_1","regionsOfInterest","scaledBoxes","prediction","predictionBoxCPU","squeeze","arraySync","scaledBox","enlargedBox","squarifiedBox","landmarks","forEach","startEndTensor","dispose","updateRegionsOfInterest","runsWithoutFaceDetector","tidy","boxLandmarksFromMeshModel","indexOfForehead","indexOfMouth","faceCenter","faceCenterNormalized","shape","rotatedImage","rotateWithOffset","boxCPU","div","flag","coords","coordsReshaped","reshape","leftEyeBox","leftEyeBoxSize","leftEyeCrop","rightEyeBox","rightEyeBoxSize","rightEyeCrop","eyePredictions","predict","eyePredictionsData","dataSync","leftEyeData","leftEyeRawCoords","leftIrisRawCoords","rightEyeData","rightEyeRawCoords","rightIrisRawCoords","leftToRightEyeDepthDifference","getLeftToRightEyeDepthDifference","Math","abs","adjustedLeftIrisCoords","getAdjustedIrisCoords","adjustedRightIrisCoords","transformedCoordsData","transformRawCoords","transformedCoords","tensor2d","landmarksBox","squarifiedLandmarksBox","__assign","scaledCoords","previousBox","iou","boxStartX","boxStartY","boxEndX","boxEndY","previousBoxStartX","previousBoxStartY","previousBoxEndX","previousBoxEndY","xStartMax","max","yStartMax","xEndMin","min","yEndMin","intersection","boxArea","previousBoxArea","roisCount","noROIs","xs","ys","apply","exports"],"sources":["../../src/mediapipe-facemesh/pipeline.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}